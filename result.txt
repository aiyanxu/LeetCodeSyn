Remove Linked List Elements =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode removeElements(ListNode head, int val) {\u000D\u000A        if(head \u003D\u003D null)\u000D\u000A            return null\u003B\u000D\u000A        while (head !\u003D null \u0026\u0026 head.val \u003D\u003D val){\u000D\u000A            head \u003D head.next\u003B\u000D\u000A        }\u000D\u000A        if(head \u003D\u003D null)\u000D\u000A            return null\u003B\u000D\u000A        ListNode pre \u003D head,p \u003D head\u003B\u000D\u000A        while(p !\u003D null){\u000D\u000A            if(p.val \u003D\u003D val){\u000D\u000A                pre.next \u003D p.next\u003B\u000D\u000A            }\u000D\u000A            else{\u000D\u000A                pre \u003D p\u003B\u000D\u000A            }\u000D\u000A            p \u003D p.next\u003B\u000D\u000A        }\u000D\u000A        return head\u003B\u000D\u000A    }\u000D\u000A}';
Happy Number =>     scope.code.python = 'class Solution:\u000D\u000A    # @param {integer} n\u000D\u000A    # @return {boolean}\u000D\u000A    def isHappy(self, n):\u000D\u000A        used \u003D set()\u000D\u000A        while n !\u003D 1 and not n in used:\u000D\u000A            used.add(n)\u000D\u000A            next \u003D 0\u000D\u000A            s \u003D str(n)\u000D\u000A            for i in range(len(s)):\u000D\u000A                next +\u003D int(s[i]) * int(s[i])\u000D\u000A            n \u003D next\u000D\u000A        if n \u003D\u003D 1:\u000D\u000A            return True\u000D\u000A        return False\u000D\u000A        ';
Happy Number =>     scope.code.python = 'class Solution:\u000D\u000A    # @param {integer} n\u000D\u000A    # @return {boolean}\u000D\u000A    def isHappy(self, n):\u000D\u000A        used \u003D set()\u000D\u000A        while n !\u003D 1 and not n in used:\u000D\u000A            used.add(n)\u000D\u000A            next \u003D 0\u000D\u000A            for i in range(len(str(n))):\u000D\u000A                next +\u003D int(str(n)[i]) * int(str(n)[i])\u000D\u000A            n \u003D next\u000D\u000A        if n \u003D\u003D 1:\u000D\u000A            return True\u000D\u000A        return False\u000D\u000A            \u000D\u000A        ';
Bitwise AND of Numbers Range =>     scope.code.python = 'class Solution:\u000D\u000A    def rangeBitwiseAnd(self,m,n):\u000D\u000A        p \u003D 0\u000D\u000A        while m !\u003D n:\u000D\u000A            m \u003E\u003E\u003D 1\u000D\u000A            n \u003E\u003E\u003D 1\u000D\u000A            p +\u003D 1\u000D\u000A        return m \u003C\u003C p';
Binary Tree Right Side View =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ArrayList\u003CInteger\u003E rightSideView(TreeNode root){\u000D\u000A        ArrayList\u003CInteger\u003E res \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        if (root \u003D\u003D null)\u000D\u000A            return res\u003B\u000D\u000A        Queue\u003CTreeNode\u003E queue \u003D new LinkedList\u003CTreeNode\u003E()\u003B\u000D\u000A        queue.add(root)\u003B\u000D\u000A        int current \u003D 1\u003B\u000D\u000A        int next \u003D 0\u003B\u000D\u000A        while (!queue.isEmpty()){\u000D\u000A            TreeNode node \u003D queue.poll()\u003B\u000D\u000A            current\u002D\u002D\u003B\u000D\u000A            if (node.left !\u003D null){\u000D\u000A                queue.add(node.left)\u003B\u000D\u000A                next++\u003B\u000D\u000A            }\u000D\u000A            if (node.right !\u003D null){\u000D\u000A                queue.add(node.right)\u003B\u000D\u000A                next++\u003B\u000D\u000A            }\u000D\u000A            if (current \u003D\u003D 0){\u000D\u000A                res.add(node.val)\u003B\u000D\u000A                current \u003D next\u003B\u000D\u000A                next \u003D 0\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
House Robber =>     scope.code.python = 'class Solution:\u000D\u000A    def rob(self,num):\u000D\u000A        length \u003D len(num)\u000D\u000A        res \u003D []\u000D\u000A        if length \u003D\u003D 0:\u000D\u000A            return 0\u000D\u000A        if length \u003D\u003D 1:\u000D\u000A            return num[0]\u000D\u000A        elif length \u003D\u003D 2:\u000D\u000A            return max(num[0],num[1])\u000D\u000A        else:\u000D\u000A            res.append(num[0])\u000D\u000A            res.append(num[1])\u000D\u000A            for i in range(2,length):\u000D\u000A                val1 \u003D num[i] + res[i\u002D2]\u000D\u000A                if i\u002D3 \u003E\u003D 0:\u000D\u000A                    val2 \u003D num[i] + res[i\u002D3]\u000D\u000A                else:\u000D\u000A                    val2 \u003D 0\u000D\u000A                res.append(max(val1,val2))\u000D\u000A        return max(res[length\u002D1],res[length\u002D2])\u000D\u000A';
Number of 1 Bits =>     scope.code.python = 'class Solution:\u000D\u000A    def hammingWeight(self,n):\u000D\u000A        count \u003D 0\u000D\u000A        while n !\u003D 0:\u000D\u000A            n \u0026\u003D (n\u002D1)\u000D\u000A            count +\u003D 1\u000D\u000A        return count';
Number of 1 Bits =>     scope.code.python = 'class Solution:\u000D\u000A    def hammingWeight(self,n):\u000D\u000A        count \u003D 0\u000D\u000A        while n !\u003D 0:\u000D\u000A            if n % 2 \u003D\u003D 1:\u000D\u000A                count +\u003D 1\u000D\u000A            n /\u003D 2\u000D\u000A        return count';
Number of 1 Bits =>     scope.code.python = 'class Solution:\u000D\u000A    def hammingWeight(self,n):\u000D\u000A        count \u003D 0\u000D\u000A        while n !\u003D 0:\u000D\u000A            count +\u003D n \u0026 1\u000D\u000A            n \u003D n \u003E\u003E 1\u000D\u000A        return count';
Number of 1 Bits =>     scope.code.python = 'class Solution:\u000D\u000A    def hammingWeight(self,n):\u000D\u000A        current \u003D 1\u000D\u000A        count \u003D 0\u000D\u000A        for i in range(32):\u000D\u000A            res \u003D current \u0026 n\u000D\u000A            if res \u003D\u003D current:\u000D\u000A                count +\u003D 1\u000D\u000A            current \u003D current \u003C\u003C 1\u000D\u000A        return count';
Reverse Bits =>     scope.code.python = 'class Solution:\u000D\u000A  def reverseBits(self,n):\u000D\u000A    current \u003D 1\u000D\u000A    res \u003D 0\u000D\u000A    for i in range(32):\u000D\u000A      flag \u003D current \u0026 n\u000D\u000A      if flag \u003D\u003D current:\u000D\u000A        res +\u003D pow(2,31\u002Di)\u000D\u000A      current \u003D current \u003C\u003C 1\u000D\u000A    return res';
Rotate Array =>     scope.code.python = 'class Solution:\u000D\u000A    def rotate(self,nums,k):\u000D\u000A        size \u003D len(nums)\u000D\u000A        section2size \u003D k % size\u000D\u000A        section1size \u003D size \u002D section2size\u000D\u000A        for i in range(section1size/2):\u000D\u000A            nums[i],nums[section1size\u002Di\u002D1] \u003D nums[section1size\u002Di\u002D1],nums[i]\u000D\u000A        for i in range(section2size/2):\u000D\u000A            nums[i+section1size],nums[section2size\u002Di\u002D1+section1size] \u003D nums[section2size\u002Di\u002D1+section1size],nums[i+section1size]\u000D\u000A        for i in range(size/2):\u000D\u000A            nums[i],nums[size\u002D1\u002Di] \u003D nums[size\u002D1\u002Di],nums[i]\u000D\u000A';
Repeated DNA Sequences =>     scope.code.python = 'class Solution:\u000D\u000A  def findRepeatedDnaSequences(self,s):\u000D\u000A    ans \u003D []\u000D\u000A    h \u003D {\u0027A\u0027: 0,\u0027C\u0027: 1,\u0027G\u0027: 2,\u0027T\u0027: 3 }\u000D\u000A    valCnt \u003D dict()\u000D\u000A    sum \u003D 0\u000D\u000A    for x in range(len(s)):\u000D\u000A      sum \u003D (sum * 4 + h[s[x]]) \u0026 0xFFFFF\u000D\u000A      if x \u003C 9:\u000D\u000A        continue\u000D\u000A      valCnt[sum] \u003D valCnt.get(sum,0) + 1\u000D\u000A      if valCnt[sum] \u003D\u003D 2:\u000D\u000A        ans.append(s[x\u002D9:x+1])\u000D\u000A    return ans\u000D\u000A';
Largest Number =>     scope.code.java = 'public class Solution {\u000D\u000A     public String largestNumber(int[] num){\u000D\u000A        Integer[] tmp \u003D new Integer[num.length]\u003B\u000D\u000A        int i \u003D 0\u003B\u000D\u000A        for(int val : num)\u000D\u000A            tmp[i++] \u003D Integer.valueOf(val)\u003B\u000D\u000A        Arrays.sort(tmp,new Comparator\u003CInteger\u003E(){\u000D\u000A            public int compare(Integer o1, Integer o2){\u000D\u000A                return (Integer.toString(o2) + Integer.toString(o1)).compareTo(Integer.toString(o1)+Integer.toString(o2))\u003B\u000D\u000A            }\u000D\u000A        })\u003B\u000D\u000A        StringBuilder sb \u003D new StringBuilder()\u003B\u000D\u000A        for (int val : tmp)\u000D\u000A            sb.append(Integer.toString(val))\u003B\u000D\u000A        String res \u003D  sb.toString().replaceAll(\u0022^0+\u0022,\u0022\u0022)\u003B\u000D\u000A        if (res.equals(\u0022\u0022))\u000D\u000A            return \u00220\u0022\u003B\u000D\u000A        else\u000D\u000A            return res\u003B\u000D\u000A    }\u000D\u000A}';
Largest Number =>     scope.code.python = 'class Solution:\u000D\u000A    # @param num, a list of integers\u000D\u000A    # @return a string\u000D\u000A    def largestNumber(self,num):\u000D\u000A        num.sort(lambda x,y: cmp(str(x)+str(y),str(y)+str(x)),reverse\u003DTrue)\u000D\u000A        s \u003D \u0027\u0027\u000D\u000A        for i in num:\u000D\u000A            s +\u003D str(i)\u000D\u000A        s \u003D \u00220\u0022 if s.lstrip(\u00220\u0022) \u003D\u003D \u0022\u0022 else s.lstrip()\u000D\u000A        return s\u000D\u000A        ';
Factorial Trailing Zeroes =>     scope.code.cpp = 'class Solution {\u000D\u000Apublic:\u000D\u000A    int trailingZeroes(int n) {\u000D\u000A        int ret \u003D 0\u003B\u000D\u000A        while(n){\u000D\u000A            ret +\u003D n / 5\u003B\u000D\u000A            n /\u003D 5\u003B\u000D\u000A        }\u000D\u000A        return ret\u003B\u000D\u000A    }\u000D\u000A}\u003B';
Factorial Trailing Zeroes =>     scope.code.python = 'class Solution:\u000D\u000A    # @return an integer\u000D\u000A    def trailingZeroes(self, n):\u000D\u000A        res \u003D 0\u000D\u000A        x \u003D 5\u000D\u000A        while n \u003E\u003D x:\u000D\u000A            res +\u003D n/x\u000D\u000A            x *\u003D 5\u000D\u000A        return res\u000D\u000A        ';
Factorial Trailing Zeroes =>     scope.code.java = 'public class Solution {\u000D\u000A    public int trailingZeroes(int n) {\u000D\u000A        int res \u003D 0\u003B\u000D\u000A        int x \u003D 5\u003B\u000D\u000A        while(n \u003E\u003D x) {\u000D\u000A            res +\u003D n/x\u003B\u000D\u000A            x *\u003D 5\u003B\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Excel Sheet Column Number =>     scope.code.java = 'public class Solution {\u000D\u000A    public int titleToNumber(String s){\u000D\u000A        byte[] arr \u003D s.toUpperCase().getBytes()\u003B\u000D\u000A        int result \u003D 0\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Carr.length\u003Bi++){\u000D\u000A            int tmp \u003D arr[i] \u002D 64\u003B\u000D\u000A            result +\u003D tmp * Math.pow(26,arr.length\u002D1\u002Di)\u003B\u000D\u000A        }\u000D\u000A        return result\u003B\u000D\u000A    }\u000D\u000A}';
Majority Element =>     scope.code.cpp = '#include\u003Cvector\u003E\u000D\u000A#include\u003Cmap\u003E\u000D\u000Ausing namespace std\u003B\u000D\u000A\u000D\u000Aclass Solution {\u000D\u000Apublic:\u000D\u000A    int majorityElement(vector\u003Cint\u003E \u0026num) {\u000D\u000A        map\u003Cint,int\u003E m\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cnum.size()\u003Bi++){\u000D\u000A            if(m.find(num.at(i)) \u003D\u003D m.end())\u000D\u000A                m[num.at(i)] \u003D 1\u003B\u000D\u000A            else\u000D\u000A                m[num.at(i)] +\u003D 1\u003B\u000D\u000A            if(m[num.at(i)] \u003E num.size() / 2)\u000D\u000A                return num.at(i)\u003B\u000D\u000A        }\u000D\u000A        return 0\u003B\u000D\u000A    }\u000D\u000A}\u003B';
Majority Element =>     scope.code.java = 'public class Solution {\u000D\u000A    public int majorityElement(int[] num) {\u000D\u000A        int threshold \u003D num.length / 2\u003B\u000D\u000A\u0009\u0009HashMap\u003CInteger,Integer\u003E tmp \u003D new HashMap\u003CInteger,Integer\u003E()\u003B\u000D\u000A\u0009\u0009for(int i : num){\u000D\u000A\u0009\u0009\u0009if(tmp.containsKey(i))\u000D\u000A\u0009\u0009\u0009\u0009tmp.put(i, tmp.get(i)+1)\u003B\u000D\u000A\u0009\u0009\u0009else\u000D\u000A\u0009\u0009\u0009\u0009tmp.put(i, 1)\u003B\u000D\u000A\u0009\u0009\u0009if(tmp.get(i) \u003E threshold)\u000D\u000A\u0009\u0009\u0009\u0009return i\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Majority Element =>     scope.code.java = 'public class Solution {\u000D\u000A    public int majorityElement(int[] num) {\u000D\u000A        int threshold \u003D num.length / 2\u003B\u000D\u000A\u0009\u0009HashMap\u003CInteger,Integer\u003E tmp \u003D new HashMap\u003CInteger,Integer\u003E()\u003B\u000D\u000A\u0009\u0009for(int i : num){\u000D\u000A\u0009\u0009\u0009if(tmp.containsKey(i))\u000D\u000A\u0009\u0009\u0009\u0009tmp.put(i, tmp.get(i)+1)\u003B\u000D\u000A\u0009\u0009\u0009else\u000D\u000A\u0009\u0009\u0009\u0009tmp.put(i, 1)\u003B\u000D\u000A\u0009\u0009\u0009if(tmp.get(i) \u003E threshold)\u000D\u000A\u0009\u0009\u0009\u0009return i\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Excel Sheet Column Title =>     scope.code.java = 'public class Solution {\u000D\u000A    public String convertToTitle(int n) {\u000D\u000A        List\u003CInteger\u003E tmplist \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        HashMap\u003CInteger,String\u003E transform \u003D new HashMap\u003CInteger, String\u003E()\u003B\u000D\u000A        transform.put(1,\u0022A\u0022)\u003B\u000D\u000A        transform.put(2,\u0022B\u0022)\u003B\u000D\u000A        transform.put(3,\u0022C\u0022)\u003B\u000D\u000A        transform.put(4,\u0022D\u0022)\u003B\u000D\u000A        transform.put(5,\u0022E\u0022)\u003B\u000D\u000A        transform.put(6,\u0022F\u0022)\u003B\u000D\u000A        transform.put(7,\u0022G\u0022)\u003B\u000D\u000A        transform.put(8,\u0022H\u0022)\u003B\u000D\u000A        transform.put(9,\u0022I\u0022)\u003B\u000D\u000A        transform.put(10,\u0022J\u0022)\u003B\u000D\u000A        transform.put(11,\u0022K\u0022)\u003B\u000D\u000A        transform.put(12,\u0022L\u0022)\u003B\u000D\u000A        transform.put(13,\u0022M\u0022)\u003B\u000D\u000A        transform.put(14,\u0022N\u0022)\u003B\u000D\u000A        transform.put(15,\u0022O\u0022)\u003B\u000D\u000A        transform.put(16,\u0022P\u0022)\u003B\u000D\u000A        transform.put(17,\u0022Q\u0022)\u003B\u000D\u000A         transform.put(18,\u0022R\u0022)\u003B\u000D\u000A        transform.put(19,\u0022S\u0022)\u003B\u000D\u000A        transform.put(20,\u0022T\u0022)\u003B\u000D\u000A        transform.put(21,\u0022U\u0022)\u003B\u000D\u000A        transform.put(22,\u0022V\u0022)\u003B\u000D\u000A        transform.put(23,\u0022W\u0022)\u003B\u000D\u000A        transform.put(24,\u0022X\u0022)\u003B\u000D\u000A        transform.put(25,\u0022Y\u0022)\u003B\u000D\u000A        transform.put(0,\u0022Z\u0022)\u003B\u000D\u000A\u000D\u000A\u000D\u000A        while(n !\u003D 0){\u000D\u000A            int last \u003D n % 26\u003B\u000D\u000A            tmplist.add(last)\u003B\u000D\u000A            if(last \u003D\u003D 0)\u000D\u000A                n \u002D\u003D 26\u003B\u000D\u000A            n \u003D n / 26\u003B\u000D\u000A        }\u000D\u000A\u000D\u000A        StringBuilder sb \u003D new StringBuilder()\u003B\u000D\u000A        for(int i\u003Dtmplist.size()\u002D1\u003Bi\u003E\u003D0\u003Bi\u002D\u002D){\u000D\u000A            sb.append(transform.get(tmplist.get(i)))\u003B\u000D\u000A        }\u000D\u000A\u000D\u000A        return sb.toString()\u003B\u000D\u000A    }\u000D\u000A}';
Fraction to Recurring Decimal =>     scope.code.java = 'public class Solution {\u000D\u000A   public String fractionToDecimal(int numerator,int denominator){\u000D\u000A        if(numerator \u003D\u003D 0)\u000D\u000A            return \u00220\u0022\u003B\u000D\u000A        String res \u003D \u0022\u0022\u003B\u000D\u000A        if(numerator \u003C 0 ^ denominator \u003C 0)\u000D\u000A            res +\u003D \u0022\u002D\u0022\u003B\u000D\u000A        long num \u003D numerator,den \u003D denominator\u003B\u000D\u000A        num \u003D Math.abs(num)\u003B\u000D\u000A        den \u003D Math.abs(den)\u003B\u000D\u000A        res +\u003D num/den\u003B\u000D\u000A        long r \u003D num % den\u003B\u000D\u000A        if(r \u003D\u003D 0)\u000D\u000A            return res\u003B\u000D\u000A        else\u000D\u000A            res +\u003D \u0022.\u0022\u003B\u000D\u000A        HashMap\u003CLong,Integer\u003E map \u003D new HashMap\u003CLong,Integer\u003E()\u003B\u000D\u000A        while(r !\u003D 0){\u000D\u000A            if(map.containsKey(r)){\u000D\u000A                int beg \u003D map.get(r)\u003B\u000D\u000A                String part1 \u003D res.substring(0,beg)\u003B\u000D\u000A                String part2 \u003D res.substring(beg,res.length())\u003B\u000D\u000A                res \u003D part1 + \u0022(\u0022 + part2 + \u0022)\u0022\u003B\u000D\u000A                return res\u003B\u000D\u000A            }\u000D\u000A            map.put(r,res.length())\u003B\u000D\u000A            r *\u003D 10\u003B\u000D\u000A            res +\u003D r/den\u003B\u000D\u000A            r \u003D r % den\u003B\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Compare Version Numbers =>     scope.code.java = 'public class Solution {\u000D\u000A    public int compareVersion(String version1, String version2) {\u000D\u000A        String[] tmp1 \u003D version1.split(\u0022\u005C\u005C.\u0022)\u003B\u000D\u000A        String[] tmp2 \u003D version2.split(\u0022\u005C\u005C.\u0022)\u003B\u000D\u000A        int commonLength \u003D tmp1.length \u003C tmp2.length ? tmp1.length : tmp2.length\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003CcommonLength\u003Bi++){\u000D\u000A            int a \u003D Integer.parseInt(tmp1[i])\u003B\u000D\u000A            int b \u003D Integer.parseInt(tmp2[i])\u003B\u000D\u000A            if(a \u003C b)\u000D\u000A                return \u002D1\u003B\u000D\u000A            else if(a\u003Eb)\u000D\u000A                return 1\u003B\u000D\u000A            else\u000D\u000A                continue\u003B\u000D\u000A        }\u000D\u000A        if(tmp1.length \u003E tmp2.length){\u000D\u000A            for(int i\u003DcommonLength\u003Bi\u003Ctmp1.length\u003Bi++){\u000D\u000A                if(Integer.parseInt(tmp1[i]) !\u003D 0)\u000D\u000A                    return 1\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        if (tmp1.length \u003C tmp2.length){\u000D\u000A                for(int i\u003DcommonLength\u003Bi\u003Ctmp2.length\u003Bi++){\u000D\u000A                    if(Integer.parseInt(tmp2[i]) !\u003D 0)\u000D\u000A                        return \u002D1\u003B\u000D\u000A                }\u000D\u000A        }\u000D\u000A\u000D\u000A        return 0\u003B\u000D\u000A    }\u000D\u000A}';
Maximum Gap =>     scope.code.python = 'class Solution:\u000D\u000A    def maximumGap(self,num):\u000D\u000A        l \u003D sorted(num)\u000D\u000A        maxdiff \u003D 0\u000D\u000A        for i in range(len(l)\u002D1):\u000D\u000A            diff \u003D l[i+1] \u002D l[i]\u000D\u000A            if diff \u003E maxdiff:\u000D\u000A                maxdiff \u003D diff\u000D\u000A        return maxdiff';
Find Peak Element =>     scope.code.java = 'public class Solution {\u000D\u000A    public int findPeakElement(int[] num) {\u000D\u000A        return find_peak_element(num,0,num.length\u002D1)\u003B\u000D\u000A    }\u000D\u000A    \u000D\u000A    private int find_peak_element(int[] num, int low, int high){\u000D\u000A\u0009\u0009int mid \u003D (low+high)/2\u003B\u000D\u000A\u0009\u0009if((mid \u003D\u003D 0 || num[mid] \u003E\u003D num[mid\u002D1]) \u0026\u0026 (mid \u003D\u003D num.length\u002D1 || num[mid] \u003E\u003D num[mid+1]))\u000D\u000A\u0009\u0009\u0009return mid\u003B\u000D\u000A\u0009\u0009else if(mid \u003E 0 \u0026\u0026 num[mid] \u003C num[mid\u002D1])\u000D\u000A\u0009\u0009\u0009return find_peak_element(num,low,mid\u002D1)\u003B\u000D\u000A\u0009\u0009else\u000D\u000A\u0009\u0009\u0009return find_peak_element(num,mid+1,high)\u003B\u000D\u000A\u0009}\u000D\u000A}';
Find Peak Element =>     scope.code.java = 'public class Solution {\u000D\u000A    public int findPeakElement(int[] num) {\u000D\u000A        if(num.length \u003D\u003D 1)\u000D\u000A\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009if(num[0] \u003E num[1])\u000D\u000A\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009for(int i\u003D1\u003B i\u003Cnum.length\u002D1\u003Bi++){\u000D\u000A\u0009\u0009\u0009if(num[i] \u003E num[i\u002D1] \u0026\u0026 num[i] \u003E num[i+1])\u000D\u000A\u0009\u0009\u0009\u0009return i\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return num.length\u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Intersection of Two Linked Lists =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\u000D\u000A        ListNode p \u003D headA\u003B\u000D\u000A\u0009\u0009ListNode q \u003D headB\u003B\u000D\u000A\u0009\u0009if(headA \u003D\u003D null || headB \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return null\u003B\u000D\u000A\u0009\u0009int m \u003D0,n \u003D 0\u003B\u000D\u000A\u0009\u0009while(headA !\u003D null){\u000D\u000A\u0009\u0009\u0009m +\u003D 1\u003B\u000D\u000A\u0009\u0009\u0009headA \u003D headA.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(headB !\u003D null){\u000D\u000A\u0009\u0009\u0009n +\u003D 1\u003B\u000D\u000A\u0009\u0009\u0009headB \u003D headB.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009int i \u003D Math.abs(m\u002Dn)\u003B\u000D\u000A\u0009\u0009if(m\u003E\u003Dn){\u000D\u000A\u0009\u0009\u0009while(i\u003E0){\u000D\u000A\u0009\u0009\u0009\u0009p \u003D p.next\u003B\u000D\u000A\u0009\u0009\u0009\u0009i\u002D\u002D\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009while(i\u003E0){\u000D\u000A\u0009\u0009\u0009\u0009q \u003D q.next\u003B\u000D\u000A\u0009\u0009\u0009\u0009i\u002D\u002D\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(p !\u003D null \u0026\u0026 q !\u003D null){\u000D\u000A\u0009\u0009\u0009if(p \u003D\u003D q)\u000D\u000A\u0009\u0009\u0009\u0009return p\u003B\u000D\u000A\u0009\u0009\u0009p \u003D p.next\u003B\u000D\u000A\u0009\u0009\u0009q \u003D q.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return null\u003B\u000D\u000A        \u000D\u000A    }\u000D\u000A}';

Find Minimum in Rotated Sorted Array II =>     scope.code.java = 'public class Solution {\u000D\u000A    public int findMin(int num[]){\u000D\u000A        return helper(num,0,num.length\u002D1)\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private int helper(int[] num,int low,int high){\u000D\u000A        if(low \u003E high)\u000D\u000A            return num[0]\u003B\u000D\u000A        if(low \u003D\u003D high)\u000D\u000A            return num[low]\u003B\u000D\u000A        int mid \u003D (low+high)/2\u003B\u000D\u000A        if(mid\u003Chigh \u0026\u0026 num[mid+1] \u003C num[mid])\u000D\u000A            return num[mid+1]\u003B\u000D\u000A        if(mid\u003Elow \u0026\u0026 num[mid] \u003C num[mid\u002D1])\u000D\u000A            return num[mid]\u003B\u000D\u000A        if(num[low] \u003D\u003D num[mid] \u0026\u0026 num[high] \u003D\u003D num[mid])\u000D\u000A            return Math.min(helper(num,low,mid\u002D1),helper(num,mid+1,high))\u003B\u000D\u000A        if(num[high] \u003E\u003D num[mid])\u000D\u000A            return helper(num,low,mid\u002D1)\u003B\u000D\u000A        return helper(num,mid+1,high)\u003B\u000D\u000A    }\u000D\u000A}';
Find Minimum in Rotated Sorted Array =>     scope.code.java = 'public class Solution {\u000D\u000A    public int findMin(int[] num){\u000D\u000A        if (num.length \u003D\u003D 1)\u000D\u000A            return num[0]\u003B\u000D\u000A        int low \u003D 0\u003B\u000D\u000A        int high \u003D num.length\u002D1\u003B\u000D\u000A        int mid\u003B\u000D\u000A        while (low \u003C high){\u000D\u000A            mid \u003D (low+high)/2\u003B\u000D\u000A            if(mid \u003C high \u0026\u0026 num[mid+1] \u003C num[mid])\u000D\u000A                return num[mid+1]\u003B\u000D\u000A            if(mid \u003E low \u0026\u0026 num[mid]\u003Cnum[mid\u002D1])\u000D\u000A                return num[mid]\u003B\u000D\u000A            if(num[high] \u003E num[mid]){\u000D\u000A                high \u003D mid\u002D1\u003B\u000D\u000A            }\u000D\u000A            else{\u000D\u000A                low \u003D mid+1\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return num[(low+high)/2]\u003B\u000D\u000A    }\u000D\u000A}';
Find Minimum in Rotated Sorted Array =>     scope.code.java = 'public class Solution {\u000D\u000A    public int findMin(int[] num) {\u000D\u000A        if(num.length \u003D\u003D 1)\u000D\u000A\u0009\u0009\u0009return num[0]\u003B\u000D\u000A\u0009\u0009if((num[0] \u003C num[1]) \u0026\u0026 (num[0] \u003C num[num.length\u002D1]))\u000D\u000A\u0009\u0009\u0009return num[0]\u003B\u000D\u000A\u0009\u0009if((num[num.length\u002D1] \u003C num[0]) \u0026\u0026 (num[num.length\u002D1] \u003C num[num.length\u002D2]))\u000D\u000A\u0009\u0009\u0009return num[num.length\u002D1]\u003B\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009for(int i\u003D1\u003Bi\u003C\u003Dnum.length\u002D2\u003Bi++){\u000D\u000A\u0009\u0009\u0009if((num[i] \u003C num[i\u002D1]) \u0026\u0026 (num[i] \u003C num[i+1])){\u000D\u000A\u0009\u0009\u0009\u0009return num[i]\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Maximum Product Subarray =>     scope.code.java = 'public class Solution {\u000D\u000A    public int maxProduct(int[] A) {\u000D\u000A        if(A.length \u003D\u003D 1)\u000D\u000A\u0009\u0009\u0009return A[0]\u003B\u000D\u000A\u0009\u0009int max_local \u003D A[0]\u003B\u000D\u000A\u0009\u0009int max_global \u003D A[0]\u003B\u000D\u000A\u0009\u0009int min_local \u003D A[0]\u003B\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009for(int i\u003D1\u003B i\u003C A.length\u003B i++){\u000D\u000A\u0009\u0009\u0009int max_copy \u003D max_local\u003B\u000D\u000A\u0009\u0009\u0009max_local \u003D Math.max(Math.max(max_local*A[i], A[i]), A[i]*min_local)\u003B\u000D\u000A\u0009\u0009\u0009min_local \u003D Math.min(Math.min(A[i], max_copy*A[i]), A[i]*min_local)\u003B\u000D\u000A\u0009\u0009\u0009max_global \u003D Math.max(max_local, max_global)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return max_global\u003B\u000D\u000A    }\u000D\u000A}';
Reverse Words in a String =>     scope.code.java = 'public class Solution {\u000D\u000A    public String reverseWords(String s) {\u000D\u000A        String res \u003D \u0022\u0022\u003B\u000D\u000A\u0009\u0009String[] array \u003D s.trim().replaceAll(\u0022 +\u0022,\u0022 \u0022).split(\u0022 \u0022)\u003B\u000D\u000A\u0009\u0009for(int i\u003D0,j\u003Darray.length\u002D1\u003B i\u003C j\u003Bi++,j\u002D\u002D){\u000D\u000A\u0009\u0009\u0009String tmp \u003D array[i].trim()\u003B\u000D\u000A\u0009\u0009\u0009array[i] \u003Darray[j].trim()\u003B\u000D\u000A\u0009\u0009\u0009array[j] \u003D tmp\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009for( String str : array){\u000D\u000A\u0009\u0009\u0009res +\u003D str + \u0022 \u0022\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return res.trim()\u003B\u000D\u000A    }\u000D\u000A}';
Evaluate Reverse Polish Notation =>     scope.code.java = 'public class Solution {\u000D\u000A    public int evalRPN(String[] tokens) {\u000D\u000A        if(tokens \u003D\u003D null || tokens.length \u003D\u003D 0)\u000D\u000A            return 0\u003B\u000D\u000A        Stack\u003CInteger\u003E stack \u003D new Stack\u003CInteger\u003E()\u003B\u000D\u000A        for(String s : tokens){\u000D\u000A            if(s.equals(\u0022+\u0022)){\u000D\u000A                int a \u003D stack.pop()\u003B\u000D\u000A                int b \u003D stack.pop()\u003B\u000D\u000A                stack.push(b+a)\u003B\u000D\u000A            }\u000D\u000A            else if(s.equals(\u0022\u002D\u0022)){\u000D\u000A                int a \u003D stack.pop()\u003B\u000D\u000A                int b \u003D stack.pop()\u003B\u000D\u000A                stack.push(b\u002Da)\u003B\u000D\u000A            }\u000D\u000A            else if(s.equals(\u0022*\u0022)){\u000D\u000A                int a \u003D stack.pop()\u003B\u000D\u000A                int b \u003D stack.pop()\u003B\u000D\u000A                stack.push(b*a)\u003B\u000D\u000A            }\u000D\u000A            else if(s.equals(\u0022/\u0022)){\u000D\u000A                int a \u003D stack.pop()\u003B\u000D\u000A                int b \u003D stack.pop()\u003B\u000D\u000A                stack.push(b/a)\u003B\u000D\u000A            }\u000D\u000A            else{\u000D\u000A                stack.push(Integer.valueOf(s))\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return stack.peek()\u003B\u000D\u000A    }\u000D\u000A}';
Max Points on a Line =>     scope.code.python = 'import sys\u000D\u000Aclass Solution:\u000D\u000A    def maxPoints(self,points):\u000D\u000A        if not points or len(points) \u003C 1:\u000D\u000A            return 0\u000D\u000A        maxpoints \u003D 0\u000D\u000A        size \u003D len(points)\u000D\u000A        count \u003D [1] * size\u000D\u000A        points.sort(key\u003Dlambda p: p.x)\u000D\u000A        h \u003D []\u000D\u000A        for i in range(size):\u000D\u000A            h.append({})\u000D\u000A        for i in range(size\u002D1):\u000D\u000A            for j in range(i+1,size):\u000D\u000A                if points[j].x \u003D\u003D points[i].x and points[j].y \u003D\u003D points[i].y:\u000D\u000A                    count[j] \u003D count[i] + 1\u000D\u000A                    if h[i]:\u000D\u000A                        for key,value in h[i].iteritems():\u000D\u000A                            h[j][key] \u003D value + 1\u000D\u000A                    continue\u000D\u000A                if points[j].x \u003D\u003D points[i].x:\u000D\u000A                    k \u003D sys.maxint\u000D\u000A                else:\u000D\u000A                    k \u003D float(points[j].y\u002Dpoints[i].y)/(points[j].x\u002Dpoints[i].x)\u000D\u000A                if h[i].get(k):\u000D\u000A                    h[j][k] \u003D h[i].get(k) + 1\u000D\u000A                else:\u000D\u000A                    h[j][k] \u003D count[i]\u000D\u000A        for i in range(len(h)):\u000D\u000A            if h[i]:\u000D\u000A                maxpoints \u003D max(max(h[i].values())+1,maxpoints)\u000D\u000A            else:\u000D\u000A                maxpoints \u003D max(maxpoints,count[i])\u000D\u000A        return maxpoints';
Max Points on a Line =>     scope.code.python = 'import sys\u000D\u000Aclass Solution:\u000D\u000A    def maxPoints(self,points):\u000D\u000A        if not points or len(points) \u003C 1:\u000D\u000A            return 0\u000D\u000A        maxpoints \u003D 0\u000D\u000A        size \u003D len(points)\u000D\u000A        count \u003D [1] * size\u000D\u000A        points.sort(key\u003Dlambda p: p.x)\u000D\u000A        h \u003D []\u000D\u000A        for i in range(size):\u000D\u000A            h.append({})\u000D\u000A        for i in range(size\u002D1):\u000D\u000A            for j in range(i+1,size):\u000D\u000A                if points[j].x \u003D\u003D points[i].x and points[j].y \u003D\u003D points[i].y:\u000D\u000A                    count[j] \u003D count[i] + 1\u000D\u000A                    if h[i]:\u000D\u000A                        for key,value in h[i].iteritems():\u000D\u000A                            h[j][key] \u003D value + 1\u000D\u000A                    continue\u000D\u000A                if points[j].x \u003D\u003D points[i].x:\u000D\u000A                    k \u003D sys.maxint\u000D\u000A                else:\u000D\u000A                    k \u003D float(points[j].y\u002Dpoints[i].y)/(points[j].x\u002Dpoints[i].x)\u000D\u000A                if h[i].get(k):\u000D\u000A                    h[j][k] \u003D h[i].get(k) + 1\u000D\u000A                else:\u000D\u000A                    h[j][k] \u003D h[i].get(k,0) + count[i]\u000D\u000A        for i in range(len(h)):\u000D\u000A            if h[i]:\u000D\u000A                maxpoints \u003D max(max(h[i].values())+1,maxpoints)\u000D\u000A            else:\u000D\u000A                maxpoints \u003D max(maxpoints,count[i])\u000D\u000A        return maxpoints';
Sort List =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode sortList(ListNode head){\u000D\u000A        return mergeSort(head)\u003B\u000D\u000A    }\u000D\u000A    private ListNode mergeSort(ListNode head){\u000D\u000A        if(head \u003D\u003D null || head.next \u003D\u003D null)\u000D\u000A            return head\u003B\u000D\u000A        ListNode head1 \u003D head\u003B\u000D\u000A        ListNode walker \u003D head\u003B\u000D\u000A        ListNode runner \u003D head\u003B\u000D\u000A        while (runner.next !\u003D null \u0026\u0026 runner.next.next !\u003D null){\u000D\u000A            walker \u003D walker.next\u003B\u000D\u000A            runner \u003D runner.next.next\u003B\u000D\u000A        }\u000D\u000A        ListNode head2 \u003D walker.next\u003B\u000D\u000A        walker.next \u003D null\u003B\u000D\u000A        head1 \u003D mergeSort(head1)\u003B\u000D\u000A        head2 \u003D mergeSort(head2)\u003B\u000D\u000A        return merge(head1,head2)\u003B\u000D\u000A    }\u000D\u000A    private ListNode merge(ListNode l1, ListNode l2){\u000D\u000A        ListNode p \u003D l1,q \u003D l2\u003B\u000D\u000A        ListNode fakeHead \u003D new ListNode(0)\u003B\u000D\u000A        ListNode f \u003D fakeHead\u003B\u000D\u000A        while(p !\u003D null \u0026\u0026 q !\u003D null){\u000D\u000A            if(p.val \u003C\u003D q.val ){\u000D\u000A                f.next \u003D p\u003B\u000D\u000A                p \u003D p.next\u003B\u000D\u000A            }else{\u000D\u000A                f.next \u003D q\u003B\u000D\u000A                q \u003D q.next\u003B\u000D\u000A            }\u000D\u000A            f \u003D f.next\u003B\u000D\u000A        }\u000D\u000A        if(p !\u003D null)\u000D\u000A            f.next \u003D p\u003B\u000D\u000A        if(q !\u003D null)\u000D\u000A            f.next \u003D q\u003B\u000D\u000A        return fakeHead.next\u003B\u000D\u000A    }\u000D\u000A}';
Insertion Sort List =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode insertionSortList(ListNode head){\u000D\u000A        if(head \u003D\u003D null)\u000D\u000A            return head\u003B\u000D\u000A        ListNode newHead \u003D new ListNode(head.val)\u003B\u000D\u000A        ListNode ppre \u003D head\u003B\u000D\u000A        ListNode p \u003D head.next\u003B\u000D\u000A        while(p !\u003D null){\u000D\u000A            ppre.next \u003D p.next\u003B\u000D\u000A            if(p.val \u003C\u003D newHead.val){\u000D\u000A                p.next \u003D newHead\u003B\u000D\u000A                newHead \u003D p\u003B\u000D\u000A            }\u000D\u000A            else{\u000D\u000A                ListNode q \u003D newHead.next\u003B\u000D\u000A                ListNode pre \u003DnewHead\u003B\u000D\u000A                while(q !\u003D null \u0026\u0026 !(pre.val \u003C\u003D p.val \u0026\u0026 p.val \u003C\u003D q.val)){\u000D\u000A                    pre \u003D q\u003B\u000D\u000A                    q \u003D q.next\u003B\u000D\u000A                }\u000D\u000A                pre.next \u003D p\u003B\u000D\u000A                p.next \u003D q\u003B\u000D\u000A            }\u000D\u000A            p \u003D ppre.next\u003B\u000D\u000A        }\u000D\u000A        return newHead\u003B\u000D\u000A    }\u000D\u000A}';
Binary Tree Postorder Traversal =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ArrayList\u003CInteger\u003E postorderTraversal(TreeNode root){\u000D\u000A        ArrayList\u003CInteger\u003E result \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        Stack\u003CTreeNode\u003E stack \u003D new Stack\u003CTreeNode\u003E()\u003B\u000D\u000A        TreeNode prev \u003D null\u003B\u000D\u000A        if (root \u003D\u003D null){\u000D\u000A            return result\u003B\u000D\u000A        }\u000D\u000A        stack.push(root)\u003B\u000D\u000A        while (!stack.empty()){\u000D\u000A            TreeNode curr \u003D stack.peek()\u003B\u000D\u000A            if(prev \u003D\u003D null || prev.left \u003D\u003D curr || prev.right \u003D\u003D curr){\u000D\u000A                if (curr.left !\u003D null){\u000D\u000A                    stack.push(curr.left)\u003B\u000D\u000A                }else if (curr.right !\u003D null){\u000D\u000A                    stack.push(curr.right)\u003B\u000D\u000A                }else {\u000D\u000A                    result.add(curr.val)\u003B\u000D\u000A                    stack.pop()\u003B\u000D\u000A                }\u000D\u000A            } else if (curr.left \u003D\u003D prev){\u000D\u000A                if (curr.right !\u003D null){\u000D\u000A                    stack.push(curr.right)\u003B\u000D\u000A                } else{\u000D\u000A                    result.add(curr.val)\u003B\u000D\u000A                    stack.pop()\u003B\u000D\u000A                }\u000D\u000A            } else if (curr.right \u003D\u003D prev){\u000D\u000A                result.add(curr.val)\u003B\u000D\u000A                stack.pop()\u003B\u000D\u000A            }\u000D\u000A            prev \u003D curr\u003B\u000D\u000A        }\u000D\u000A        return result\u003B\u000D\u000A    }\u000D\u000A}';
Binary Tree Preorder Traversal =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ArrayList\u003CInteger\u003E preorderTraversal(TreeNode root){\u000D\u000A        ArrayList\u003CInteger\u003E res \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        Stack\u003CTreeNode\u003E stack \u003D new Stack\u003CTreeNode\u003E()\u003B\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return res\u003B\u000D\u000A        stack.push(root)\u003B\u000D\u000A        while(!stack.isEmpty()){\u000D\u000A            TreeNode tmp \u003D stack.pop()\u003B\u000D\u000A            res.add(tmp.val)\u003B\u000D\u000A            if(tmp.right !\u003D null)\u000D\u000A                stack.push(tmp.right)\u003B\u000D\u000A            if(tmp.left !\u003D null)\u000D\u000A                stack.push(tmp.left)\u003B\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Binary Tree Preorder Traversal =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ArrayList\u003CInteger\u003E preorderTraversal(TreeNode root){\u000D\u000A        ArrayList\u003CInteger\u003E res \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return res\u003B\u000D\u000A        helper(root,res)\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A    private void helper(TreeNode root,ArrayList\u003CInteger\u003E res){\u000D\u000A        res.add(root.val)\u003B\u000D\u000A        if(root.left !\u003D null)\u000D\u000A            helper(root.left,res)\u003B\u000D\u000A        if(root.right !\u003D null)\u000D\u000A            helper(root.right,res)\u003B\u000D\u000A    }\u000D\u000A}';
Reorder List =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A   public void reorderList(ListNode head){\u000D\u000A        if(head \u003D\u003D null)\u000D\u000A            return\u003B\u000D\u000A        ListNode p \u003D head\u003B\u000D\u000A        ArrayList\u003CListNode\u003E set \u003D new ArrayList\u003CListNode\u003E()\u003B\u000D\u000A        while(p !\u003D null){\u000D\u000A            set.add(p)\u003B\u000D\u000A            p \u003D p.next\u003B\u000D\u000A        }\u000D\u000A        for (ListNode node : set)\u000D\u000A            node.next \u003D null\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cset.size()\u002D1\u002Di\u003Bi++){\u000D\u000A            set.get(i).next \u003D set.get(set.size()\u002D1\u002Di)\u003B\u000D\u000A            if (i+1 !\u003D set.size()\u002D1\u002Di)\u000D\u000A                set.get(set.size()\u002D1\u002Di).next \u003D set.get(i+1)\u003B\u000D\u000A        }\u000D\u000A    }\u000D\u000A}';
Linked List Cycle II =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A     public ListNode detectCycle(ListNode head){\u000D\u000A        if (head \u003D\u003D null)\u000D\u000A            return null\u003B\u000D\u000A        ListNode first \u003D head\u003B\u000D\u000A        ListNode second \u003D head\u003B\u000D\u000A        while (first !\u003D null \u0026\u0026 second !\u003D null){\u000D\u000A            first \u003D first.next\u003B\u000D\u000A            second \u003D second.next\u003B\u000D\u000A            if(second !\u003D null)\u000D\u000A                second \u003D second.next\u003B\u000D\u000A            if(first \u003D\u003D second)\u000D\u000A                break\u003B\u000D\u000A        }\u000D\u000A        if(second \u003D\u003D null)\u000D\u000A            return null\u003B\u000D\u000A        first \u003D head\u003B\u000D\u000A        while(first !\u003D second){\u000D\u000A            first \u003D first.next\u003B\u000D\u000A            second \u003D second.next\u003B\u000D\u000A        }\u000D\u000A        return second\u003B\u000D\u000A    }\u000D\u000A}';
Linked List Cycle =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A     public boolean hasCycle(ListNode head){\u000D\u000A        if (head \u003D\u003D null)\u000D\u000A            return false\u003B\u000D\u000A        ListNode first \u003D head\u003B\u000D\u000A        ListNode second \u003D head.next\u003B\u000D\u000A        while(first !\u003D null \u0026\u0026 second !\u003D null){\u000D\u000A            if(first \u003D\u003D second)\u000D\u000A                return true\u003B\u000D\u000A            first \u003D first.next\u003B\u000D\u000A            second \u003D second.next\u003B\u000D\u000A            if (second \u003D\u003D null){\u000D\u000A                return false\u003B\u000D\u000A            }\u000D\u000A            second \u003D second.next\u003B\u000D\u000A        }\u000D\u000A        return false\u003B\u000D\u000A    }\u000D\u000A}';
Word Break II =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CString\u003E wordBreak(String s, Set\u003CString\u003E dict){\u000D\u000A        if(s.length() \u003E 60){\u000D\u000A            if(!canBreak(s,dict))\u000D\u000A                return new ArrayList\u003CString\u003E()\u003B\u000D\u000A        }\u000D\u000A        ArrayList\u003CString\u003E[] solution \u003D new ArrayList[s.length()]\u003B\u000D\u000A        boolean[] res \u003D new boolean[s.length()]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cres.length\u003Bi++)\u000D\u000A            res[i] \u003D false\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Csolution.length\u003Bi++)\u000D\u000A            solution[i] \u003D new ArrayList\u003CString\u003E()\u003B\u000D\u000A        if(dict.contains(s.substring(0, 1))) {\u000D\u000A            res[0] \u003D true\u003B\u000D\u000A            solution[0].add(s.substring(0,1))\u003B\u000D\u000A        }\u000D\u000A        for(int i\u003D1\u003Bi\u003Cs.length()\u003Bi++){\u000D\u000A            if(dict.contains(s.substring(0,i+1))){\u000D\u000A                res[i] \u003D true\u003B\u000D\u000A                solution[i].add(s.substring(0, i + 1))\u003B\u000D\u000A            }\u000D\u000A            for(int j\u003D0\u003Bj\u003Ci\u003Bj++){\u000D\u000A                if(res[j]){\u000D\u000A                    if(dict.contains(s.substring(j+1,i+1))){\u000D\u000A                        res[i] \u003D true\u003B\u000D\u000A                        for(String tmp : solution[j]){\u000D\u000A                            solution[i].add(( tmp + \u0022 \u0022 + s.substring(j+1,i+1)).trim())\u003B\u000D\u000A                        }\u000D\u000A                    }\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return solution[solution.length\u002D1]\u003B\u000D\u000A    }\u000D\u000A    \u000D\u000A    private boolean canBreak(String s,Set\u003CString\u003E dict){\u000D\u000A        if(dict.contains(s))\u000D\u000A            return true\u003B\u000D\u000A        boolean[] res \u003D new boolean[s.length()]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cres.length\u003Bi++)\u000D\u000A            res[i] \u003D false\u003B\u000D\u000A        if(dict.contains(s.substring(0, 1)))\u000D\u000A            res[0] \u003D true\u003B\u000D\u000A        for(int i\u003D1\u003Bi\u003Cs.length()\u003Bi++){\u000D\u000A            if(dict.contains(s.substring(0,i+1))){\u000D\u000A                res[i] \u003D true\u003B\u000D\u000A                continue\u003B\u000D\u000A            }\u000D\u000A            for(int j\u003D0\u003Bj\u003Ci\u003Bj++){\u000D\u000A                if(res[j]){\u000D\u000A                    if(dict.contains(s.substring(j+1,i+1))){\u000D\u000A                        res[i] \u003D true\u003B\u000D\u000A                        break\u003B\u000D\u000A                    }\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res[res.length\u002D1]\u003B\u000D\u000A    }\u000D\u000A}';
Word Break =>     scope.code.java = 'public class Solution {\u000D\u000A   public boolean wordBreak(String s,Set\u003CString\u003E dict){\u000D\u000A        if(dict.contains(s))\u000D\u000A            return true\u003B\u000D\u000A        boolean[] res \u003D new boolean[s.length()]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cres.length\u003Bi++)\u000D\u000A            res[i] \u003D false\u003B\u000D\u000A        if(dict.contains(s.substring(0, 1)))\u000D\u000A            res[0] \u003D true\u003B\u000D\u000A        for(int i\u003D1\u003Bi\u003Cs.length()\u003Bi++){\u000D\u000A            if(dict.contains(s.substring(0,i+1))){\u000D\u000A                res[i] \u003D true\u003B\u000D\u000A                continue\u003B\u000D\u000A            }\u000D\u000A            for(int j\u003D0\u003Bj\u003Ci\u003Bj++){\u000D\u000A                if(res[j]){\u000D\u000A                    if(dict.contains(s.substring(j+1,i+1))){\u000D\u000A                        res[i] \u003D true\u003B\u000D\u000A                        break\u003B\u000D\u000A                    }\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res[res.length\u002D1]\u003B\u000D\u000A    }\u000D\u000A}';
Word Break =>     scope.code.java = 'public class Solution {\u000D\u000A   public boolean wordBreak(String s,Set\u003CString\u003E dict){\u000D\u000A        if(dict.contains(s))\u000D\u000A            return true\u003B\u000D\u000A        Set\u003CString\u003E fail \u003D new HashSet\u003CString\u003E()\u003B\u000D\u000A        return helper(s,dict,fail)\u003B\u000D\u000A    }\u000D\u000A    private boolean helper(String rest,Set\u003CString\u003E dict,Set\u003CString\u003E fail){\u000D\u000A        if(fail.contains(rest))\u000D\u000A            return false\u003B\u000D\u000A        if(dict.contains(rest))\u000D\u000A            return true\u003B\u000D\u000A        if(\u0022\u0022.equals(rest))\u000D\u000A            return true\u003B\u000D\u000A        for(int i\u003D1\u003Bi\u003C\u003Drest.length()\u003Bi++){\u000D\u000A            String subStr \u003D rest.substring(0,i)\u003B\u000D\u000A            if(dict.contains(subStr)){\u000D\u000A                if(helper(rest.substring(i),dict,fail))\u000D\u000A                    return true\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        fail.add(rest)\u003B\u000D\u000A        return false\u003B\u000D\u000A    }\u000D\u000A}';
Copy List with Random Pointer =>     scope.code.python = '# Definition for singly\u002Dlinked list with a random pointer.\u000D\u000A# class RandomListNode:\u000D\u000A#     def __init__(self, x):\u000D\u000A#         self.label \u003D x\u000D\u000A#         self.next \u003D None\u000D\u000A#         self.random \u003D None\u000D\u000A\u000D\u000Aclass Solution:\u000D\u000A    def copyRandomList(self,head):\u000D\u000A        res \u003D []\u000D\u000A        h \u003D dict()\u000D\u000A        if head is None:\u000D\u000A            return None\u000D\u000A        p \u003D head\u000D\u000A        total \u003D 0\u000D\u000A        while p:\u000D\u000A            total +\u003D 1\u000D\u000A            h[p] \u003D total\u000D\u000A            q \u003D RandomListNode(p.label)\u000D\u000A            res.append(q)\u000D\u000A            if total \u003E 1:\u000D\u000A                res[total\u002D2].next \u003D res[total\u002D1]\u000D\u000A            p \u003D p.next\u000D\u000A        current \u003D 0\u000D\u000A        p \u003D head\u000D\u000A        while p:\u000D\u000A            q \u003D p.random\u000D\u000A            if q is None:\u000D\u000A                res[current].random \u003D None\u000D\u000A            else:\u000D\u000A                res[current].random \u003D res[h[q]\u002D1]\u000D\u000A            current +\u003D 1\u000D\u000A            p \u003D p.next\u000D\u000A        return res[0]\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A        ';
Copy List with Random Pointer =>     scope.code.python = '# Definition for singly\u002Dlinked list with a random pointer.\u000D\u000A# class RandomListNode:\u000D\u000A#     def __init__(self, x):\u000D\u000A#         self.label \u003D x\u000D\u000A#         self.next \u003D None\u000D\u000A#         self.random \u003D None\u000D\u000A\u000D\u000Aclass Solution:\u000D\u000A    def copyRandomList(self,head):\u000D\u000A        res \u003D []\u000D\u000A        h \u003D dict()\u000D\u000A        if head is None:\u000D\u000A            return None\u000D\u000A        p \u003D head\u000D\u000A        total \u003D 0\u000D\u000A        while p:\u000D\u000A            total +\u003D 1\u000D\u000A            h[p] \u003D total\u000D\u000A            q \u003D RandomListNode(p.label)\u000D\u000A            res.append(q)\u000D\u000A            p \u003D p.next\u000D\u000A        current \u003D 0\u000D\u000A        p \u003D head\u000D\u000A        while p:\u000D\u000A            q \u003D p.random\u000D\u000A            if q is None:\u000D\u000A                res[current].random \u003D None\u000D\u000A            else:\u000D\u000A                res[current].random \u003D res[h[q]\u002D1]\u000D\u000A            current +\u003D 1\u000D\u000A            p \u003D p.next\u000D\u000A        for i in range(len(res)\u002D1):\u000D\u000A            res[i].next \u003D res[i+1]\u000D\u000A        return res[0]\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A        ';
Single Number II =>     scope.code.java = 'public class Solution {\u000D\u000A    public int singleNumber(int[] A){\u000D\u000A        HashMap\u003CInteger,Integer\u003E map \u003D new HashMap\u003CInteger, Integer\u003E()\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003CA.length\u003Bi++){\u000D\u000A            if(map.containsKey(A[i]))\u000D\u000A                map.put(A[i],map.get(A[i])+1)\u003B\u000D\u000A            else\u000D\u000A                map.put(A[i],1)\u003B\u000D\u000A        }\u000D\u000A        for(int k : map.keySet())\u000D\u000A            if(map.get(k) !\u003D 3)\u000D\u000A                return k\u003B\u000D\u000A        return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';

Single Number =>     scope.code.cpp = '#include \u003Cset\u003E\u000D\u000Ausing namespace std\u003B\u000D\u000Aclass Solution {\u000D\u000Apublic:\u000D\u000A    int singleNumber(int A[], int n){\u000D\u000A      set\u003Cint\u003E res\u003B\u000D\u000A      int ret\u003B\u000D\u000A      for(int i\u003D0\u003Bi\u003Cn\u003Bi++){\u000D\u000A        if (res.find(A[i]) \u003D\u003D res.end())\u000D\u000A          res.insert(A[i])\u003B\u000D\u000A        else\u000D\u000A          res.erase(A[i])\u003B\u000D\u000A      }\u000D\u000A      ret \u003D *(res.begin())\u003B\u000D\u000A      return ret\u003B\u000D\u000A    }\u000D\u000A}\u003B';
Single Number =>     scope.code.cpp = '#include \u003Cset\u003E\u000D\u000Ausing namespace std\u003B\u000D\u000Aclass Solution {\u000D\u000Apublic:\u000D\u000A    int singleNumber(int A[], int n){\u000D\u000A      set\u003Cint\u003E res\u003B\u000D\u000A      int ret\u003B\u000D\u000A      for(int i\u003D0\u003Bi\u003Cn\u003Bi++){\u000D\u000A        if (res.find(A[i]) \u003D\u003D res.end())\u000D\u000A          res.insert(A[i])\u003B\u000D\u000A        else\u000D\u000A          res.erase(A[i])\u003B\u000D\u000A      }\u000D\u000A      set\u003Cint\u003E::iterator p\u003B\u000D\u000A      for(p \u003D res.begin()\u003Bp!\u003Dres.end()\u003Bp++)\u000D\u000A        ret \u003D *p\u003B\u000D\u000A      return ret\u003B\u000D\u000A    }\u000D\u000A}\u003B';
Single Number =>     scope.code.cpp = 'class Solution {\u000D\u000Apublic:\u000D\u000A    int singleNumber(int A[], int n) {\u000D\u000A        int res \u003D 0\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cn\u003Bi++)\u000D\u000A            res \u003D res ^ A[i]\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}\u003B';
Single Number =>     scope.code.java = 'public class Solution {\u000D\u000A     public int singleNumber(int[] A){\u000D\u000A        int res \u003D 0\u003B\u000D\u000A        for(int val : A)\u000D\u000A            res \u003D res ^ val\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Single Number =>     scope.code.java = 'public class Solution {\u000D\u000A    public int singleNumber(int[] A) {\u000D\u000A        HashSet\u003CInteger\u003E tmp \u003D new HashSet\u003CInteger\u003E()\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003CA.length\u003Bi++){\u000D\u000A            if(tmp.contains(A[i]))\u000D\u000A                tmp.remove(A[i])\u003B\u000D\u000A            else\u000D\u000A                tmp.add(A[i])\u003B\u000D\u000A        }\u000D\u000A        return (Integer)(tmp.toArray()[0])\u003B\u000D\u000A    }\u000D\u000A}';
Single Number =>     scope.code.java = 'public class Solution {\u000D\u000A    public int singleNumber(int[] A) {\u000D\u000A        int res \u003D 0\u003B\u000D\u000A\u0009\u0009Map\u003CInteger,Integer\u003E tmp \u003D new HashMap\u003CInteger,Integer\u003E()\u003B\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009for(int i\u003D0\u003B i\u003CA.length\u003B i++){\u000D\u000A\u0009\u0009\u0009if(!tmp.containsKey(A[i]))\u000D\u000A\u0009\u0009\u0009\u0009tmp.put(A[i], 1)\u003B\u000D\u000A\u0009\u0009\u0009else\u000D\u000A\u0009\u0009\u0009\u0009tmp.put(A[i], tmp.get(A[i])+1)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009for(int key : tmp.keySet()){\u000D\u000A\u0009\u0009\u0009if(tmp.get(key) \u003D\u003D 1)\u000D\u000A\u0009\u0009\u0009\u0009res \u003D key\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return res\u003B\u000D\u000A    }\u000D\u000A}';
Candy =>     scope.code.java = 'public class Solution {\u000D\u000A    public int candy(int[] ratings) {\u000D\u000A\u0009\u0009 int[] candies \u003Dnew int[ratings.length]\u003B\u000D\u000A\u0009\u0009 int result \u003D 0\u003B\u000D\u000A\u0009\u0009 \u000D\u000A\u0009\u0009 for(int i\u003D0\u003B i\u003C candies.length\u003B i++)\u000D\u000A\u0009\u0009\u0009 candies[i] \u003D 1\u003B\u000D\u000A\u0009\u0009 \u000D\u000A\u0009\u0009 for(int i\u003D1\u003B i\u003C ratings.length\u003B i++){\u000D\u000A\u0009\u0009\u0009 if(ratings[i] \u003E ratings[i\u002D1])\u000D\u000A\u0009\u0009\u0009\u0009 candies[i] \u003D candies[i\u002D1] + 1\u003B\u000D\u000A\u0009\u0009 }\u000D\u000A\u0009\u0009 for(int i \u003D ratings.length\u002D2\u003B i\u003E\u003D0\u003Bi\u002D\u002D){\u000D\u000A\u0009\u0009\u0009 if((ratings[i] \u003E ratings[i+1]) \u0026\u0026 (candies[i] \u003C\u003D candies[i+1])){\u000D\u000A\u0009\u0009\u0009\u0009 candies[i] \u003D candies[i+1]+1\u003B\u000D\u000A\u0009\u0009\u0009 }\u000D\u000A\u0009\u0009 }\u000D\u000A\u0009\u0009 \u000D\u000A\u0009\u0009 for(int tmp : candies)\u000D\u000A\u0009\u0009\u0009 result +\u003D tmp\u003B\u000D\u000A\u0009\u0009 return result\u003B\u000D\u000A\u0009 }\u000D\u000A}';
Gas Station =>     scope.code.java = 'public class Solution {\u000D\u000A    public int canCompleteCircuit(int[] gas,int[] cost){\u000D\u000A        int l \u003D gas.length\u003B\u000D\u000A        int sum \u003D 0\u003B\u000D\u000A        int total \u003D 0\u003B\u000D\u000A        int j \u003D \u002D1\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cl\u003Bi++){\u000D\u000A            sum +\u003D gas[i] \u002D cost[i]\u003B\u000D\u000A            total +\u003D gas[i] \u002D cost[i]\u003B\u000D\u000A            if (sum \u003C 0){\u000D\u000A                j \u003D i\u003B\u000D\u000A                sum \u003D 0\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        if (total \u003C 0)\u000D\u000A            return \u002D1\u003B\u000D\u000A        else\u000D\u000A            return j+1\u003B\u000D\u000A    }\u000D\u000A}';
Palindrome Partitioning II =>     scope.code.python = 'class Solution:\u000D\u000A    # @param s, a string\u000D\u000A    # @return an integer\u000D\u000A   def minCut(self,s):\u000D\u000A        minCutArray \u003D [0] * len(s)\u000D\u000A        for i in range(1,len(s)):\u000D\u000A            mincut \u003D 1000\u000D\u000A            subString \u003D s[0:i+1]\u000D\u000A            if subString \u003D\u003D subString[::\u002D1]:\u000D\u000A                minCutArray[i] \u003D 0\u000D\u000A            else:\u000D\u000A                for j in range(i):\u000D\u000A                    temp \u003D s[j+1:i+1]\u000D\u000A                    if temp \u003D\u003D temp[::\u002D1]:\u000D\u000A                        if mincut \u003E minCutArray[j] + 1:\u000D\u000A                            mincut \u003D 1 + minCutArray[j]\u000D\u000A                minCutArray[i] \u003D mincut\u000D\u000A        return minCutArray[\u002D1]\u000D\u000A        ';
Palindrome Partitioning =>     scope.code.java = 'public class Solution {\u000D\u000A   public ArrayList\u003CArrayList\u003CString\u003E\u003E partition(String s){\u000D\u000A        ArrayList\u003CArrayList\u003CString\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CString\u003E\u003E()\u003B\u000D\u000A        if(s\u003D\u003D\u0022\u0022 || s.length()\u003D\u003D0 || s\u003D\u003Dnull)\u000D\u000A            return res\u003B\u000D\u000A        ArrayList\u003CString\u003E item \u003D new ArrayList\u003CString\u003E()\u003B\u000D\u000A        helper(s,0,s.length()\u002D1,item,res)\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private void helper(String s,int start,int end,ArrayList\u003CString\u003E item,ArrayList\u003CArrayList\u003CString\u003E\u003E res){\u000D\u000A        if(isEqual(s,item)){\u000D\u000A            res.add(new ArrayList\u003CString\u003E(item))\u003B\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        for(int i\u003Dstart\u003Bi\u003C\u003Dend\u003Bi++){\u000D\u000A            String tmp \u003D s.substring(start,i+1)\u003B\u000D\u000A            if(isPalindrome(tmp)){\u000D\u000A               item.add(tmp)\u003B\u000D\u000A                helper(s,i+1,end,item,res)\u003B\u000D\u000A                item.remove(item.size()\u002D1)\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private boolean isPalindrome(String a){\u000D\u000A        return new StringBuilder(a).reverse().toString().equals(a)\u003B\u000D\u000A    }\u000D\u000A    private boolean isEqual(String a, ArrayList\u003CString\u003E item){\u000D\u000A        StringBuilder sb \u003D new StringBuilder()\u003B\u000D\u000A        for(String i : item)\u000D\u000A            sb.append(i)\u003B\u000D\u000A        if(sb.toString().equals(a))\u000D\u000A            return true\u003B\u000D\u000A        return false\u003B\u000D\u000A    }\u000D\u000A}';
Sum Root to Leaf Numbers =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public int sumNumbers(TreeNode root) {\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009return helper(root,root.val)\u003B\u000D\u000A    }\u000D\u000A    \u000D\u000A    private int helper(TreeNode root,int v){\u000D\u000A\u0009\u0009if(root.left \u003D\u003D null \u0026\u0026 root.right \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return v\u003B\u000D\u000A\u0009\u0009if(root.right \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009return helper(root.left,v*10+root.left.val)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009else if(root.left \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009return helper(root.right,v*10+root.right.val)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009else{\u000D\u000A\u0009\u0009\u0009return helper(root.right,v*10+root.right.val) + helper(root.left,v*10+root.left.val)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009}\u000D\u000A}';
Longest Consecutive Sequence =>     scope.code.java = 'public class Solution {\u000D\u000A    public int longestConsecutive(int[] num){\u000D\u000A        if(num.length \u003D\u003D 0)\u000D\u000A            return 0\u003B\u000D\u000A        HashSet\u003CInteger\u003E set \u003D new HashSet\u003CInteger\u003E()\u003B\u000D\u000A        for(int n : num)\u000D\u000A            set.add(n)\u003B\u000D\u000A        int max \u003D 1\u003B\u000D\u000A        for(int n : num){\u000D\u000A            int count \u003D 1\u003B\u000D\u000A            int left \u003D n\u002D1\u003B\u000D\u000A            int right \u003D n+1\u003B\u000D\u000A\u000D\u000A            while(set.contains(left)){\u000D\u000A                count +\u003D 1\u003B\u000D\u000A                set.remove(left)\u003B\u000D\u000A                left\u002D\u002D\u003B\u000D\u000A            }\u000D\u000A            while(set.contains(right)){\u000D\u000A                count +\u003D 1\u003B\u000D\u000A                set.remove(right)\u003B\u000D\u000A                right++\u003B\u000D\u000A            }\u000D\u000A            max \u003D Math.max(max,count)\u003B\u000D\u000A        }\u000D\u000A        return max\u003B\u000D\u000A    }\u000D\u000A}';
Word Ladder =>     scope.code.java = 'public class Solution {\u000D\u000A    public int ladderLength(String start, String end, Set\u003CString\u003E dict) {\u000D\u000A        Queue\u003CString\u003E words \u003D new LinkedList\u003CString\u003E()\u003B\u000D\u000A        Queue\u003CInteger\u003E len \u003D new LinkedList\u003CInteger\u003E()\u003B\u000D\u000A        words.add(start)\u003B\u000D\u000A        len.add(1)\u003B\u000D\u000A        while(!words.isEmpty()){\u000D\u000A            String word \u003D words.poll()\u003B\u000D\u000A            int length \u003D len.poll()\u003B\u000D\u000A            if(word.equals(end))\u000D\u000A                return length\u003B\u000D\u000A            for(int i\u003D0\u003Bi\u003Cword.length()\u003Bi++){\u000D\u000A                char[] arr \u003D word.toCharArray()\u003B\u000D\u000A                for(char c \u003D \u0027a\u0027\u003B c\u003C\u003D\u0027z\u0027\u003B c++){\u000D\u000A                    if(arr[i] \u003D\u003D c)\u000D\u000A                        continue\u003B\u000D\u000A                    arr[i] \u003D c\u003B\u000D\u000A                    String str \u003D String.valueOf(arr)\u003B\u000D\u000A                    if(dict.contains(str)){\u000D\u000A                        words.add(str)\u003B\u000D\u000A                        len.add(length+1)\u003B\u000D\u000A                        dict.remove(str)\u003B\u000D\u000A                    }\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return 0\u003B\u000D\u000A    }\u000D\u000A}';
Valid Palindrome =>     scope.code.java = 'public class Solution {\u000D\u000A    public boolean isPalindrome(String s) {\u000D\u000A        if(s \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009if(s.equals(\u0022\u0022))\u000D\u000A\u0009\u0009\u0009return true\u003B\u000D\u000A\u0009\u0009String tmp \u003D s.replaceAll(\u0022[^\u005C\u005Cw\u005C\u005Cd]\u0022, \u0022\u0022).toLowerCase()\u003B\u000D\u000A\u0009\u0009for(int i\u003D0,j\u003Dtmp.length()\u002D1\u003Bi\u003Cj\u003Bi++,j\u002D\u002D){\u000D\u000A\u0009\u0009\u0009char a \u003D tmp.charAt(i)\u003B\u000D\u000A\u0009\u0009\u0009char b \u003D tmp.charAt(j)\u003B\u000D\u000A\u0009\u0009\u0009if(a \u003D\u003D b)\u000D\u000A\u0009\u0009\u0009\u0009continue\u003B\u000D\u000A\u0009\u0009\u0009else\u000D\u000A\u0009\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return true\u003B\u000D\u000A    }\u000D\u000A}';
Best Time to Buy and Sell Stock III =>     scope.code.java = 'public class Solution {\u000D\u000A    public int maxProfit(int[] prices) {\u000D\u000A         if (prices \u003D\u003D null || prices.length \u003D\u003D 0)\u000D\u000A            return 0\u003B\u000D\u000A        int[] left \u003D new int[prices.length]\u003B\u000D\u000A        int lowest \u003D prices[0]\u003B\u000D\u000A        int leftMax \u003D Integer.MIN_VALUE\u003B\u000D\u000A        for (int i\u003D0\u003Bi\u003Cprices.length\u003Bi++){\u000D\u000A            if(prices[i] \u003C lowest)\u000D\u000A                lowest \u003D prices[i]\u003B\u000D\u000A            int temp \u003D prices[i] \u002D lowest\u003B\u000D\u000A            if (temp \u003E leftMax)\u000D\u000A                leftMax \u003D temp\u003B\u000D\u000A            left[i] \u003D leftMax\u003B\u000D\u000A        }\u000D\u000A        int highest \u003D prices[prices.length\u002D1]\u003B\u000D\u000A        int rightMax \u003D Integer.MIN_VALUE\u003B\u000D\u000A        int[] right \u003D new int[prices.length]\u003B\u000D\u000A        int res \u003D 0\u003B\u000D\u000A        for (int i\u003Dprices.length\u002D1\u003Bi\u003E\u003D0\u003Bi\u002D\u002D){\u000D\u000A            if (prices[i] \u003E highest)\u000D\u000A                highest \u003D prices[i]\u003B\u000D\u000A            int temp \u003D highest \u002D prices[i]\u003B\u000D\u000A            if (temp \u003E rightMax)\u000D\u000A                rightMax \u003D temp\u003B\u000D\u000A            right[i] \u003D rightMax\u003B\u000D\u000A            res \u003D Math.max(res,right[i] + left[i])\u003B\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Best Time to Buy and Sell Stock II =>     scope.code.java = 'public class Solution {\u000D\u000A    public int maxProfit(int[] prices) {\u000D\u000A        int max_profile \u003D 0\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cprices.length\u002D1\u003Bi++){\u000D\u000A            if(prices[i] \u003C prices[i+1]){\u000D\u000A                max_profile +\u003D prices[i+1] \u002D prices[i]\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return max_profile\u003B\u000D\u000A    }\u000D\u000A}';
Best Time to Buy and Sell Stock =>     scope.code.java = 'public class Solution {\u000D\u000A    public int maxProfit(int[] prices) {\u000D\u000A        int max_profile \u003D 0\u003B\u000D\u000A\u0009\u0009int tmp_profile \u003D 0\u003B \u000D\u000A\u0009\u0009int lowest_price \u003D Integer.MAX_VALUE\u003B\u000D\u000A\u0009\u0009for(int i\u003D0\u003Bi\u003Cprices.length\u003Bi++){\u000D\u000A\u0009\u0009\u0009if(prices[i] \u003C lowest_price)\u000D\u000A\u0009\u0009\u0009\u0009lowest_price \u003D prices[i]\u003B\u000D\u000A\u0009\u0009\u0009tmp_profile \u003D prices[i]\u002Dlowest_price\u003B\u000D\u000A\u0009\u0009\u0009if(tmp_profile \u003E max_profile)\u000D\u000A\u0009\u0009\u0009\u0009max_profile \u003D tmp_profile\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return max_profile\u003B\u000D\u000A    }\u000D\u000A}';
Triangle =>     scope.code.python = 'class Solution:\u000D\u000A    # @param triangle, a list of lists of integers\u000D\u000A    # @return an integer\u000D\u000A    def minimumTotal(self,triangle):\u000D\u000A        res \u003D []\u000D\u000A        for idx, element in enumerate(triangle):\u000D\u000A            l \u003D []\u000D\u000A            if idx \u003D\u003D 0:\u000D\u000A                l.append(element[0])\u000D\u000A            else:\u000D\u000A                for i in range(0,idx+1):\u000D\u000A                    if i \u003D\u003D 0:\u000D\u000A                        l.append(res[idx\u002D1][0] + triangle[idx][0])\u000D\u000A                    elif i \u003D\u003D idx:\u000D\u000A                        l.append(triangle[idx][idx]+res[idx\u002D1][idx\u002D1])\u000D\u000A                    else:\u000D\u000A                        l.append(min(res[idx\u002D1][i],res[idx\u002D1][i\u002D1])+triangle[idx][i])\u000D\u000A            res.append(l)\u000D\u000A        return min(res[len(res)\u002D1])\u000D\u000A        ';
Pascal's Triangle II =>     scope.code.python = 'class Solution:\u000D\u000A    # @return a list of integers\u000D\u000A    def getRow(self,rowIndex):\u000D\u000A        res \u003D [0] * (rowIndex + 2)\u000D\u000A        res[1] \u003D 1\u000D\u000A        for i in range(rowIndex):\u000D\u000A            for j in range(rowIndex+1,0,\u002D1):\u000D\u000A                res[j] \u003D res[j] + res[j\u002D1]\u000D\u000A        return res[1:]\u000D\u000A        ';
Pascal's Triangle =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E generate(int numRows) {\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(numRows \u003D\u003D 0)\u000D\u000A            return res\u003B\u000D\u000A        ArrayList\u003CInteger\u003E first \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        first.add(1)\u003B\u000D\u000A        ArrayList\u003CInteger\u003E second \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        second.add(1)\u003B\u000D\u000A        second.add(1)\u003B\u000D\u000A        if(numRows \u003D\u003D 1){\u000D\u000A            res.add(first)\u003B\u000D\u000A            return res\u003B\u000D\u000A        }\u000D\u000A        if(numRows \u003D\u003D 2){\u000D\u000A            res.add(first)\u003B\u000D\u000A            res.add(second)\u003B\u000D\u000A            return res\u003B\u000D\u000A        }\u000D\u000A        res.add(first)\u003B\u000D\u000A        res.add(second)\u003B\u000D\u000A        for(int i\u003D2\u003Bi \u003C numRows\u003Bi++){\u000D\u000A            ArrayList\u003CInteger\u003E pre \u003D res.get(i\u002D1)\u003B\u000D\u000A            ArrayList\u003CInteger\u003E tmp \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A            for(int j\u003D0\u003Bj\u003C\u003Di\u003Bj++){\u000D\u000A                if(j\u003D\u003D0||j\u003D\u003Di)\u000D\u000A                    tmp.add(1)\u003B\u000D\u000A                else\u000D\u000A                    tmp.add(pre.get(j)+pre.get(j\u002D1))\u003B\u000D\u000A            }\u000D\u000A            res.add(tmp)\u003B\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Populating Next Right Pointers in Each Node II =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree with next pointer.\u000D\u000A * public class TreeLinkNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeLinkNode left, right, next\u003B\u000D\u000A *     TreeLinkNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A   public  void connect(TreeLinkNode root){\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return\u003B\u000D\u000A        Queue\u003CTreeLinkNode\u003E queue \u003D new LinkedList\u003CTreeLinkNode\u003E()\u003B\u000D\u000A        queue.add(root)\u003B\u000D\u000A        int currentLayer \u003D 1\u003B\u000D\u000A        int nextLayer \u003D 0\u003B\u000D\u000A        while(!queue.isEmpty()){\u000D\u000A            TreeLinkNode tmp \u003D queue.poll()\u003B\u000D\u000A            currentLayer \u002D\u003D 1\u003B\u000D\u000A            if(tmp.left !\u003D null){\u000D\u000A                queue.add(tmp.left)\u003B\u000D\u000A                nextLayer +\u003D 1\u003B\u000D\u000A            }\u000D\u000A            if(tmp.right !\u003D null){\u000D\u000A                queue.add(tmp.right)\u003B\u000D\u000A                nextLayer +\u003D 1\u003B\u000D\u000A            }\u000D\u000A            if(currentLayer \u003D\u003D 0){\u000D\u000A                tmp.next \u003D null\u003B\u000D\u000A                currentLayer \u003D nextLayer\u003B\u000D\u000A                nextLayer \u003D 0\u003B\u000D\u000A            }else{\u000D\u000A                tmp.next \u003D queue.peek()\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A    }\u000D\u000A}';
Populating Next Right Pointers in Each Node =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree with next pointer.\u000D\u000A * public class TreeLinkNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeLinkNode left, right, next\u003B\u000D\u000A *     TreeLinkNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public  void connect(TreeLinkNode root){\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return\u003B\u000D\u000A        Queue\u003CTreeLinkNode\u003E queue \u003D new LinkedList\u003CTreeLinkNode\u003E()\u003B\u000D\u000A        queue.add(root)\u003B\u000D\u000A        int currentLayer \u003D 1\u003B\u000D\u000A        int nextLayer \u003D 0\u003B\u000D\u000A        while(!queue.isEmpty()){\u000D\u000A            TreeLinkNode tmp \u003D queue.poll()\u003B\u000D\u000A            currentLayer \u002D\u003D 1\u003B\u000D\u000A            if(tmp.left !\u003D null){\u000D\u000A                queue.add(tmp.left)\u003B\u000D\u000A                nextLayer +\u003D 1\u003B\u000D\u000A            }\u000D\u000A            if(tmp.right !\u003D null){\u000D\u000A                queue.add(tmp.right)\u003B\u000D\u000A                nextLayer +\u003D 1\u003B\u000D\u000A            }\u000D\u000A            if(currentLayer \u003D\u003D 0){\u000D\u000A                tmp.next \u003D null\u003B\u000D\u000A                currentLayer \u003D nextLayer\u003B\u000D\u000A                nextLayer \u003D 0\u003B\u000D\u000A            }else{\u000D\u000A                tmp.next \u003D queue.peek()\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A    }\u000D\u000A}';
Distinct Subsequences =>     scope.code.java = 'public class Solution {\u000D\u000A    public int numDistinct(String S, String T){\u000D\u000A        int match[] \u003D new int[200]\u003B  \u000D\u000A        if(S.length() \u003C T.length()) return 0\u003B  \u000D\u000A        match[0] \u003D 1\u003B  \u000D\u000A        for(int i\u003D1\u003B i \u003C\u003D T.length()\u003B i++)  \u000D\u000A            match[i] \u003D 0\u003B  \u000D\u000A        for(int i\u003D1\u003B i\u003C\u003D S.length()\u003B i ++)  \u000D\u000A            for(int j \u003DT.length()\u003B j\u003E\u003D1\u003B j\u002D\u002D)  \u000D\u000A                if(S.charAt(i\u002D1) \u003D\u003D T.charAt(j\u002D1))  \u000D\u000A                    match[j]+\u003D match[j\u002D1]\u003B  \u000D\u000A        return match[T.length()]\u003B  \u000D\u000A        }  \u000D\u000A}';
Distinct Subsequences =>     scope.code.java = 'public class Solution {\u000D\u000A    public int numDistinct(String S, String T){\u000D\u000A        int match[] \u003D new int[200]\u003B  \u000D\u000A        if(S.length() \u003C T.length()) return 0\u003B  \u000D\u000A        match[0] \u003D 1\u003B  \u000D\u000A        for(int i\u003D1\u003B i \u003C\u003D T.length()\u003B i++)  \u000D\u000A            match[i] \u003D 0\u003B  \u000D\u000A        for(int i\u003D1\u003B i\u003C\u003D S.length()\u003B i ++)  \u000D\u000A            for(int j \u003DT.length()\u003B j\u003E\u003D1\u003B j\u002D\u002D)  \u000D\u000A                if(S.charAt(i\u002D1) \u003D\u003D T.charAt(j\u002D1))  \u000D\u000A                    match[j]+\u003D match[j\u002D1]\u003B  \u000D\u000A        return match[T.length()]\u003B  \u000D\u000A        }  \u000D\u000A}';
Flatten Binary Tree to Linked List =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public void flatten(TreeNode root){\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return\u003B\u000D\u000A        Stack\u003CTreeNode\u003E stack \u003D new Stack\u003CTreeNode\u003E()\u003B\u000D\u000A        ArrayList\u003CTreeNode\u003E res \u003D new ArrayList\u003CTreeNode\u003E()\u003B\u000D\u000A        stack.push(root)\u003B\u000D\u000A        while(!stack.isEmpty()){\u000D\u000A            TreeNode tmp \u003D stack.pop()\u003B\u000D\u000A            res.add(tmp)\u003B\u000D\u000A            if(tmp.right !\u003D null)\u000D\u000A                stack.push(tmp.right)\u003B\u000D\u000A            if(tmp.left !\u003D null)\u000D\u000A                stack.push(tmp.left)\u003B\u000D\u000A        }\u000D\u000A        for(int i\u003D0\u003Bi\u003Cres.size()\u002D1\u003Bi++){\u000D\u000A            res.get(i).left \u003D null\u003B\u000D\u000A            res.get(i).right \u003D res.get(i+1)\u003B\u000D\u000A        }\u000D\u000A        res.get(res.size()\u002D1).right \u003D null\u003B\u000D\u000A        res.get(res.size()\u002D1).left \u003D null\u003B\u000D\u000A    }\u000D\u000A}';
Path Sum II =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A     public ArrayList\u003CArrayList\u003CInteger\u003E\u003E pathSum(TreeNode root,int sum){\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        ArrayList\u003CInteger\u003E l \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        pathSumHelper(root, sum, res,l)\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private void pathSumHelper(TreeNode root, int sum, ArrayList\u003CArrayList\u003CInteger\u003E\u003E res,ArrayList\u003CInteger\u003E l){\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return\u003B\u000D\u000A        if(root.val \u003D\u003D sum \u0026\u0026 root.left \u003D\u003D null \u0026\u0026 root.right \u003D\u003D null){\u000D\u000A            l.add(root.val)\u003B\u000D\u000A            ArrayList\u003CInteger\u003E tmp \u003D new ArrayList\u003CInteger\u003E(l)\u003B\u000D\u000A            res.add(tmp)\u003B\u000D\u000A            l.remove(l.size()\u002D1)\u003B\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        l.add(root.val)\u003B\u000D\u000A        pathSumHelper(root.left,sum\u002Droot.val,res,l)\u003B\u000D\u000A        pathSumHelper(root.right,sum\u002Droot.val,res,l)\u003B\u000D\u000A        l.remove(l.size()\u002D1)\u003B\u000D\u000A    }\u000D\u000A}';
Path Sum =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public boolean hasPathSum(TreeNode root, int sum) {\u000D\u000A        if(root \u003D\u003D null){\u000D\u000A            return false\u003B\u000D\u000A        }\u000D\u000A        if(root.val \u003D\u003D sum \u0026\u0026 root.left \u003D\u003D null \u0026\u0026 root.right \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009return true\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return hasPathSum(root.left,sum\u002Droot.val) || hasPathSum(root.right,sum\u002Droot.val)\u003B\u000D\u000A    }\u000D\u000A}';
Path Sum =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    boolean find \u003D false\u003B\u000D\u000A    public boolean hasPathSum(TreeNode root, int sum) {\u000D\u000A        if(root \u003D\u003D null){\u000D\u000A            return false\u003B\u000D\u000A        }\u000D\u000A        if(root.val \u003D\u003D sum \u0026\u0026 root.left \u003D\u003D null \u0026\u0026 root.right \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009find \u003D true\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009if(root.left !\u003D null){\u000D\u000A\u0009\u0009\u0009hasPathSum(root.left,sum\u002Droot.val)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009if(root.right !\u003D null){\u000D\u000A\u0009\u0009\u0009hasPathSum(root.right,sum\u002Droot.val)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return find\u003B\u000D\u000A    }\u000D\u000A}';
Minimum Depth of Binary Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public int minDepth(TreeNode root) {\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009if(root.left \u003D\u003D null \u0026\u0026 root.right \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return 1\u003B\u000D\u000A\u0009\u0009else if(root.left \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return 1 + minDepth(root.right)\u003B\u000D\u000A\u0009\u0009else if(root.right \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return 1 + minDepth(root.left)\u003B\u000D\u000A\u0009\u0009else\u000D\u000A\u0009\u0009\u0009return 1 + Math.min(minDepth(root.left), minDepth(root.right))\u003B\u000D\u000A    }\u000D\u000A}';
Balanced Binary Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public boolean isBalanced(TreeNode root) {\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return true\u003B\u000D\u000A        if(root.left \u003D\u003D null \u0026\u0026 root.right \u003D\u003D null)\u000D\u000A            return true\u003B\u000D\u000A        if(Math.abs(depth(root.left)\u002Ddepth(root.right)) \u003E 1)\u000D\u000A            return false\u003B\u000D\u000A\u000D\u000A        return isBalanced(root.left) \u0026\u0026 isBalanced(root.right)\u003B\u000D\u000A    }\u000D\u000A    \u000D\u000A    private int depth(TreeNode root){\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return 0\u003B\u000D\u000A        return 1 + Math.max(depth(root.left),depth(root.right))\u003B\u000D\u000A    }\u000D\u000A}';
Convert Sorted List to Binary Search Tree =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) { val \u003D x\u003B next \u003D null\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000A/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A     public TreeNode sortedListToBST(ListNode head){\u000D\u000A        if(head \u003D\u003D null)\u000D\u000A            return null\u003B\u000D\u000A        return helper(head)\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private TreeNode helper(ListNode head){\u000D\u000A        if (head \u003D\u003D null)\u000D\u000A            return null\u003B\u000D\u000A        if (head.next \u003D\u003D null)\u000D\u000A            return new TreeNode(head.val)\u003B\u000D\u000A        ListNode walker \u003D head\u003B\u000D\u000A        ListNode runner \u003D head\u003B\u000D\u000A        ListNode pre \u003D head\u003B\u000D\u000A        while(runner.next !\u003D null \u0026\u0026 runner.next.next !\u003D null){\u000D\u000A            pre \u003D walker\u003B\u000D\u000A            walker \u003D walker.next\u003B\u000D\u000A            runner \u003D runner.next.next\u003B\u000D\u000A        }\u000D\u000A        ListNode head2 \u003D walker.next\u003B\u000D\u000A        pre.next \u003D null\u003B\u000D\u000A        TreeNode root \u003D new TreeNode(walker.val)\u003B\u000D\u000A        if(pre \u003D\u003D walker)\u000D\u000A            root.left \u003D null\u003B\u000D\u000A        else\u000D\u000A            root.left \u003D helper(head)\u003B\u000D\u000A        root.right \u003D helper(head2)\u003B\u000D\u000A        return root\u003B\u000D\u000A    }\u000D\u000A}';
Convert Sorted Array to Binary Search Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A   public TreeNode sortedArrayToBST(int[] num){\u000D\u000A        if(num \u003D\u003D null || num.length \u003D\u003D 0)\u000D\u000A            return null\u003B\u000D\u000A        return helper(num,0,num.length\u002D1)\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    public TreeNode helper(int[] num,int start,int end){\u000D\u000A        if(start \u003D\u003D end)\u000D\u000A            return new TreeNode(num[start])\u003B\u000D\u000A        if(start \u003E end)\u000D\u000A            return null\u003B\u000D\u000A        int mid \u003D (start+end)/2\u003B\u000D\u000A        TreeNode root \u003D new TreeNode(num[mid])\u003B\u000D\u000A        root.left \u003D helper(num,start,mid\u002D1)\u003B\u000D\u000A        root.right \u003D helper(num,mid+1,end)\u003B\u000D\u000A        return root\u003B\u000D\u000A    }\u000D\u000A}';
Binary Tree Level Order Traversal II =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E levelOrderBottom(TreeNode root) {\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E resverse \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return res\u003B\u000D\u000A        LinkedList\u003CTreeNode\u003E queue \u003D new LinkedList\u003CTreeNode\u003E()\u003B\u000D\u000A        queue.add(root)\u003B\u000D\u000A        int curNum \u003D 0\u003B\u000D\u000A        int lastNum \u003D 1\u003B\u000D\u000A        ArrayList\u003CInteger\u003E list \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        while(!queue.isEmpty()){\u000D\u000A            TreeNode tmp \u003D queue.poll()\u003B\u000D\u000A            lastNum\u002D\u002D\u003B\u000D\u000A            list.add(tmp.val)\u003B\u000D\u000A            if(tmp.left !\u003D null){\u000D\u000A                queue.add(tmp.left)\u003B\u000D\u000A                curNum++\u003B\u000D\u000A            }\u000D\u000A            if(tmp.right !\u003D null){\u000D\u000A                queue.add(tmp.right)\u003B\u000D\u000A                curNum++\u003B\u000D\u000A            }\u000D\u000A            if(lastNum \u003D\u003D 0){\u000D\u000A                lastNum \u003D curNum\u003B\u000D\u000A                curNum \u003D 0\u003B\u000D\u000A                res.add(list)\u003B\u000D\u000A                list \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        for(int i\u003Dres.size()\u002D1\u003Bi\u003E\u003D0\u003Bi\u002D\u002D)\u000D\u000A            resverse.add(res.get(i))\u003B\u000D\u000A        return resverse\u003B\u000D\u000A    }\u000D\u000A}';
Construct Binary Tree from Inorder and Postorder Traversal =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public TreeNode buildTree(int[] inorder, int[] postorder){\u000D\u000A        return helper(inorder,0,inorder.length\u002D1,postorder,0,postorder.length\u002D1)\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private TreeNode helper(int[] inorder,int istart,int iend,int[] postorder,int pstart,int pend){\u000D\u000A        if(istart \u003E iend || pstart \u003E pend)\u000D\u000A            return null\u003B\u000D\u000A        TreeNode root \u003D new TreeNode(postorder[pend])\u003B\u000D\u000A        int idx \u003D findRootIndex(postorder,pend,inorder,istart,iend)\u003B\u000D\u000A        root.left \u003D helper(inorder,istart,idx\u002D1,postorder,pstart,pstart+idx\u002Distart\u002D1)\u003B\u000D\u000A        root.right \u003D helper(inorder,idx+1,iend,postorder,pend\u002Diend+idx,pend\u002D1)\u003B\u000D\u000A        return root\u003B\u000D\u000A    }\u000D\u000A    private int findRootIndex(int[] postorder,int pend,int[] inorder,int istart,int iend){\u000D\u000A        for(int i\u003Distart\u003Bi\u003C\u003Diend\u003Bi++){\u000D\u000A            if(inorder[i] \u003D\u003D postorder[pend])\u000D\u000A                return i\u003B\u000D\u000A        }\u000D\u000A        return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Construct Binary Tree from Preorder and Inorder Traversal =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public TreeNode buildTree(int[] preorder,int[] inorder){\u000D\u000A        return helper(preorder,0,preorder.length\u002D1,inorder,0,inorder.length\u002D1)\u003B\u000D\u000A    }\u000D\u000A    private TreeNode helper(int[] preorder,int pstart, int pend, int[] inorder, int istart, int iend){\u000D\u000A        if(pstart \u003E pend || istart \u003E iend){\u000D\u000A            return null\u003B\u000D\u000A        }\u000D\u000A        TreeNode root \u003D new TreeNode(preorder[pstart])\u003B\u000D\u000A        int idx \u003D findRootIndex(preorder,pstart,inorder,istart,iend)\u003B\u000D\u000A        root.left \u003D helper(preorder,pstart+1,pstart+idx\u002Distart,inorder,istart,idx\u002D1)\u003B\u000D\u000A        root.right \u003D helper(preorder,idx\u002Diend+pend+1,pend,inorder,idx+1,iend)\u003B\u000D\u000A        return root\u003B\u000D\u000A    }\u000D\u000A    private int findRootIndex(int[] preorder,int pstart,int[] inorder,int istart,int iend){\u000D\u000A        for(int i\u003Distart\u003Bi\u003C\u003Diend\u003Bi++){\u000D\u000A            if(inorder[i] \u003D\u003D preorder[pstart])\u000D\u000A                return i\u003B\u000D\u000A        }\u000D\u000A        return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Maximum Depth of Binary Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public int maxDepth(TreeNode root) {\u000D\u000A        if(root \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009if(root.left \u003D\u003D null \u0026\u0026 root.right \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009return 1\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009if(root.left \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009return  1 + maxDepth(root.right)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009else if(root.right \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009return 1 + maxDepth(root.left)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009else{\u000D\u000A\u0009\u0009\u0009return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\u003B\u000D\u000A\u0009\u0009}\u000D\u000A    }\u000D\u000A}';
Binary Tree Zigzag Level Order Traversal =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E zigzagLevelOrder(TreeNode root) {\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if (root \u003D\u003D null)\u000D\u000A            return res\u003B\u000D\u000A        ArrayList\u003CInteger\u003E item \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        Queue\u003CTreeNode\u003E queue \u003D new LinkedList\u003CTreeNode\u003E()\u003B\u000D\u000A        queue.add(root)\u003B\u000D\u000A        boolean direction \u003D true\u003B\u000D\u000A        int currentlayernumber \u003D 1\u003B\u000D\u000A        int nextlayernumber \u003D 0\u003B\u000D\u000A        while (!queue.isEmpty()) {\u000D\u000A            TreeNode tmp \u003D queue.poll()\u003B\u000D\u000A            currentlayernumber \u002D\u003D 1\u003B\u000D\u000A            item.add(tmp.val)\u003B\u000D\u000A            if (tmp.left !\u003D null) {\u000D\u000A                queue.add(tmp.left)\u003B\u000D\u000A                nextlayernumber +\u003D 1\u003B\u000D\u000A            }\u000D\u000A            if (tmp.right !\u003D null) {\u000D\u000A                queue.add(tmp.right)\u003B\u000D\u000A                nextlayernumber +\u003D 1\u003B\u000D\u000A\u000D\u000A            }\u000D\u000A            if (currentlayernumber \u003D\u003D 0) {\u000D\u000A                if(direction)\u000D\u000A                    res.add(new ArrayList\u003CInteger\u003E(item))\u003B\u000D\u000A                else{\u000D\u000A                    ArrayList\u003CInteger\u003E temp \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A                    for(int i\u003Ditem.size()\u002D1\u003Bi\u003E\u003D0\u003Bi\u002D\u002D)\u000D\u000A                        temp.add(item.get(i))\u003B\u000D\u000A                    res.add(temp)\u003B\u000D\u000A                }\u000D\u000A                item.clear()\u003B\u000D\u000A                direction \u003D !direction\u003B\u000D\u000A                currentlayernumber \u003D nextlayernumber\u003B\u000D\u000A                nextlayernumber \u003D 0\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        if(item !\u003D null \u0026\u0026 item.size() !\u003D 0){\u000D\u000A            if(direction)\u000D\u000A                res.add(new ArrayList\u003CInteger\u003E(item))\u003B\u000D\u000A            else{\u000D\u000A                ArrayList\u003CInteger\u003E temp \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A                for(int i\u003Ditem.size()\u002D1\u003Bi\u003E\u003D0\u003Bi\u002D\u002D)\u000D\u000A                    temp.add(item.get(i))\u003B\u000D\u000A                res.add(temp)\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Binary Tree Level Order Traversal =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A   public ArrayList\u003CArrayList\u003CInteger\u003E\u003E levelOrder(TreeNode root){\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return res\u003B\u000D\u000A        LinkedList\u003CTreeNode\u003E queue \u003D new LinkedList\u003CTreeNode\u003E()\u003B\u000D\u000A        queue.add(root)\u003B\u000D\u000A        int curNum \u003D 0\u003B\u000D\u000A        int lastNum \u003D 1\u003B\u000D\u000A        ArrayList\u003CInteger\u003E list \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        while(!queue.isEmpty()){\u000D\u000A            TreeNode tmp \u003D queue.poll()\u003B\u000D\u000A            lastNum\u002D\u002D\u003B\u000D\u000A            list.add(tmp.val)\u003B\u000D\u000A            if(tmp.left !\u003D null){\u000D\u000A                queue.add(tmp.left)\u003B\u000D\u000A                curNum++\u003B\u000D\u000A            }\u000D\u000A            if(tmp.right !\u003D null){\u000D\u000A                queue.add(tmp.right)\u003B\u000D\u000A                curNum++\u003B\u000D\u000A            }\u000D\u000A            if(lastNum \u003D\u003D 0){\u000D\u000A                lastNum \u003D curNum\u003B\u000D\u000A                curNum \u003D 0\u003B\u000D\u000A                res.add(list)\u003B\u000D\u000A                list \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Symmetric Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public boolean isSymmetric(TreeNode root) {\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return true\u003B\u000D\u000A        LinkedList\u003CTreeNode\u003E queue \u003D new LinkedList\u003CTreeNode\u003E()\u003B\u000D\u000A        queue.add(root)\u003B\u000D\u000A        int curNum \u003D 1\u003B\u000D\u000A        while(curNum \u003E 0){\u000D\u000A            int i\u003D0\u003B\u000D\u000A            while(i\u003CcurNum){\u000D\u000A                TreeNode tmp \u003D queue.get(i)\u003B\u000D\u000A                i++\u003B\u000D\u000A                if(tmp \u003D\u003D null)\u000D\u000A                    continue\u003B\u000D\u000A                queue.add(tmp.left)\u003B\u000D\u000A                queue.add(tmp.right)\u003B\u000D\u000A            }\u000D\u000A            int start \u003D 0,end \u003D curNum \u002D 1\u003B\u000D\u000A            while(start\u003C end){\u000D\u000A                TreeNode p \u003D queue.get(start)\u003B\u000D\u000A                TreeNode q \u003D queue.get(end)\u003B\u000D\u000A                int l \u003D p\u003D\u003Dnull? \u002D1 : p.val\u003B\u000D\u000A                int r \u003D q\u003D\u003Dnull? \u002D1 : q.val\u003B\u000D\u000A                if(l !\u003D r)\u000D\u000A                    return false\u003B\u000D\u000A                start++\u003B\u000D\u000A                end\u002D\u002D\u003B\u000D\u000A            }\u000D\u000A            queue.subList(0,curNum).clear()\u003B\u000D\u000A            curNum \u003D queue.size()\u003B\u000D\u000A        }\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A}';
Symmetric Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public boolean isSymmetric(TreeNode root) {\u000D\u000A         if(root \u003D\u003D null)\u000D\u000A            return true\u003B\u000D\u000A        LinkedList\u003CTreeNode\u003E queue \u003D new LinkedList\u003CTreeNode\u003E()\u003B\u000D\u000A        queue.add(root)\u003B\u000D\u000A        int curNum \u003D 0\u003B\u000D\u000A        int lastNum \u003D 1\u003B\u000D\u000A        ArrayList\u003CTreeNode\u003E list \u003D new ArrayList\u003CTreeNode\u003E()\u003B\u000D\u000A        while(!queue.isEmpty()){\u000D\u000A            TreeNode tmp \u003D queue.poll()\u003B\u000D\u000A            lastNum\u002D\u002D\u003B\u000D\u000A            list.add(tmp)\u003B\u000D\u000A            if(tmp !\u003D null) {\u000D\u000A                queue.add(tmp.left)\u003B\u000D\u000A                curNum++\u003B\u000D\u000A                queue.add(tmp.right)\u003B\u000D\u000A                curNum++\u003B\u000D\u000A            }\u000D\u000A            if(lastNum \u003D\u003D 0){\u000D\u000A                int start \u003D 0, end \u003D list.size()\u002D1\u003B\u000D\u000A                while(start \u003C end){\u000D\u000A                    TreeNode p \u003D list.get(start)\u003B\u000D\u000A                    TreeNode q \u003D list.get(end)\u003B\u000D\u000A                    int l \u003D p\u003D\u003Dnull? \u002D1 : p.val\u003B\u000D\u000A                    int r \u003D q\u003D\u003Dnull? \u002D1 : q.val\u003B\u000D\u000A                    if(l !\u003D r)\u000D\u000A                        return false\u003B\u000D\u000A                    start++\u003B\u000D\u000A                    end\u002D\u002D\u003B\u000D\u000A                }\u000D\u000A                lastNum \u003D curNum\u003B\u000D\u000A                curNum \u003D 0\u003B\u000D\u000A                list \u003D new ArrayList\u003CTreeNode\u003E()\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A}';
Symmetric Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public boolean isSymmetric(TreeNode root) {\u000D\u000A         if(root \u003D\u003D null)\u000D\u000A            return true\u003B\u000D\u000A        return symmetric(root.left,root.right)\u003B\u000D\u000A    }\u000D\u000A    \u000D\u000A    private boolean symmetric(TreeNode left,TreeNode right){\u000D\u000A        if(left \u003D\u003D null)\u000D\u000A            return right \u003D\u003D null\u003B\u000D\u000A        if(right \u003D\u003D null)\u000D\u000A            return left \u003D\u003D null\u003B\u000D\u000A        if(left.val !\u003D right.val)\u000D\u000A            return false\u003B\u000D\u000A        if(!symmetric(left.right,right.left))\u000D\u000A            return false\u003B\u000D\u000A        if(!symmetric(left.left,right.right))\u000D\u000A            return false\u003B\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A}';
Same Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public boolean isSameTree(TreeNode p, TreeNode q) {\u000D\u000A        if(p \u003D\u003D null \u0026\u0026 q \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return true\u003B\u000D\u000A\u0009\u0009if(p \u003D\u003D null \u0026\u0026 q !\u003D null)\u000D\u000A\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009if(p !\u003D null \u0026\u0026 q \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009if(p !\u003D null \u0026\u0026 q !\u003D null){\u000D\u000A\u0009\u0009\u0009if(p.val \u003D\u003D q.val){\u000D\u000A\u0009\u0009\u0009\u0009return isSameTree(p.left,q.left) \u0026\u0026 isSameTree(p.right,q.right)\u003B\u000D\u000A\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return false\u003B\u000D\u000A    }\u000D\u000A}';
Validate Binary Search Tree =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public boolean isValidBST(TreeNode root){\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return true\u003B\u000D\u000A        ArrayList\u003CInteger\u003E res \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        helper(root,res)\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cres.size()\u002D1\u003Bi++){\u000D\u000A            if(res.get(i) \u003E\u003D res.get(i+1))\u000D\u000A                return false\u003B\u000D\u000A        }\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private void helper(TreeNode root,ArrayList\u003CInteger\u003E res){\u000D\u000A        if(root.left !\u003D null)\u000D\u000A            helper(root.left,res)\u003B\u000D\u000A        res.add(root.val)\u003B\u000D\u000A        if(root.right !\u003D null)\u000D\u000A            helper(root.right,res)\u003B\u000D\u000A    }\u000D\u000A}';
Unique Binary Search Trees =>     scope.code.java = 'public class Solution {\u000D\u000A   public int numTrees(int n){\u000D\u000A        if(n\u003C2)\u000D\u000A            return 1\u003B\u000D\u000A        int[] array \u003D new int[n+1]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Carray.length\u003Bi++)\u000D\u000A            array[i] \u003D 0\u003B\u000D\u000A        array[0] \u003D 1\u003B\u000D\u000A        array[1] \u003D 1\u003B\u000D\u000A        for(int i\u003D2\u003Bi\u003C\u003Dn\u003Bi++){\u000D\u000A            for(int j\u003D0\u003Bj\u003Ci\u003Bj++)\u000D\u000A                array[i] +\u003D array[j]*array[i\u002Dj\u002D1]\u003B\u000D\u000A        }\u000D\u000A        return array[n]\u003B\u000D\u000A   }\u000D\u000A}';
Binary Tree Inorder Traversal =>     scope.code.java = '/**\u000D\u000A * Definition for binary tree\u000D\u000A * public class TreeNode {\u000D\u000A *     int val\u003B\u000D\u000A *     TreeNode left\u003B\u000D\u000A *     TreeNode right\u003B\u000D\u000A *     TreeNode(int x) { val \u003D x\u003B }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A   public ArrayList\u003CInteger\u003E inorderTraversal(TreeNode root){\u000D\u000A        ArrayList\u003CInteger\u003E res \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        if(root \u003D\u003D null)\u000D\u000A            return res\u003B\u000D\u000A        Stack\u003CTreeNode\u003E stack \u003D new Stack\u003CTreeNode\u003E()\u003B\u000D\u000A        TreeNode p \u003D root\u003B\u000D\u000A        while(!stack.isEmpty() || p !\u003D null){\u000D\u000A            if(p !\u003D null) {\u000D\u000A                stack.push(p)\u003B\u000D\u000A                p \u003D p.left\u003B\u000D\u000A            }else{\u000D\u000A                TreeNode tmp \u003D stack.pop()\u003B\u000D\u000A                res.add(tmp.val)\u003B\u000D\u000A                p \u003D tmp.right\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Restore IP Addresses =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CString\u003E restoreIpAddresses(String s){\u000D\u000A        return restore(new int[0],s)\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private ArrayList\u003CString\u003E restore(int[] tokens,String rest){\u000D\u000A        ArrayList\u003CString\u003E total \u003D new ArrayList\u003CString\u003E()\u003B\u000D\u000A        if(tokens.length \u003D\u003D 4){\u000D\u000A            if(\u0022\u0022.equals(rest)){\u000D\u000A                String ip \u003D \u0022\u0022\u003B\u000D\u000A                for(int i\u003D0\u003Bi\u003C4\u003Bi++){\u000D\u000A                    if(!\u0022\u0022.equals(ip))\u000D\u000A                        ip +\u003D \u0027.\u0027\u003B\u000D\u000A                    ip +\u003D String.valueOf(tokens[i])\u003B\u000D\u000A                }\u000D\u000A                total.add(ip)\u003B\u000D\u000A            }\u000D\u000A            return total\u003B\u000D\u000A        }\u000D\u000A\u000D\u000A        for(int i\u003D1\u003Bi\u003C\u003D3 \u0026\u0026 i\u003C\u003Drest.length()\u003Bi++){\u000D\u000A            String subStr \u003D rest.substring(0,i)\u003B\u000D\u000A            int sub \u003D Integer.parseInt(subStr)\u003B\u000D\u000A            if((subStr.startsWith(\u00220\u0022) \u0026\u0026 i\u003E1) || sub \u003E 255)\u000D\u000A                break\u003B\u000D\u000A            int[] ts \u003D new int[tokens.length+1]\u003B\u000D\u000A            System.arraycopy(tokens,0,ts,0,tokens.length)\u003B\u000D\u000A            ts[tokens.length] \u003D sub\u003B\u000D\u000A            total.addAll(restore(ts,rest.substring(i)))\u003B\u000D\u000A        }\u000D\u000A        return total\u003B\u000D\u000A    }\u000D\u000A}';
Decode Ways =>     scope.code.java = 'public class Solution {\u000D\u000A     public int numDecodings(String s) {\u000D\u000A        if (s.equals(\u0022\u0022) || s\u003D\u003Dnull)\u000D\u000A            return 0\u003B\u000D\u000A        int[] res \u003D new int[s.length()]\u003B\u000D\u000A        String first \u003D s.substring(0,1)\u003B\u000D\u000A        if(first.equals(\u00220\u0022))\u000D\u000A            return 0\u003B\u000D\u000A        else\u000D\u000A            res[0] \u003D 1\u003B\u000D\u000A        for(int i\u003D1\u003Bi\u003Cs.length()\u003Bi++){\u000D\u000A            if(i\u003D\u003D1){\u000D\u000A                if (Integer.valueOf(s.substring(i,i+1)) !\u003D 0){\u000D\u000A                    if (Integer.valueOf(s.substring(i\u002D1,i+1)) \u003C\u003D 26)\u000D\u000A                        res[1] \u003D 2\u003B\u000D\u000A                    else\u000D\u000A                        res[1] \u003D 1\u003B\u000D\u000A                }\u000D\u000A                else{\u000D\u000A                    if (Integer.valueOf(s.substring(i\u002D1,i+1)) \u003C\u003D 26)\u000D\u000A                        res[1] \u003D 1\u003B\u000D\u000A                    else\u000D\u000A                        return 0\u003B\u000D\u000A                }\u000D\u000A                continue\u003B\u000D\u000A            }\u000D\u000A            String current \u003D s.substring(i,i+1)\u003B\u000D\u000A            String combine \u003D s.substring(i\u002D1,i+1)\u003B\u000D\u000A            String previous \u003D s.substring(i\u002D1,i)\u003B\u000D\u000A            if(Integer.valueOf(current) \u003D\u003D 0){\u000D\u000A                if (Integer.valueOf(previous) \u003D\u003D 0)\u000D\u000A                    return 0\u003B\u000D\u000A                else{\u000D\u000A                    if(Integer.valueOf(combine) \u003E 26)\u000D\u000A                        return 0\u003B\u000D\u000A                    else\u000D\u000A                        res[i] \u003D res[i\u002D2]\u003B\u000D\u000A                }\u000D\u000A            }else{\u000D\u000A                if (Integer.valueOf(previous) \u003D\u003D 0)\u000D\u000A                    res[i] \u003D res[i\u002D1]\u003B\u000D\u000A                else {\u000D\u000A                    if (Integer.valueOf(combine) \u003C\u003D 26) {\u000D\u000A                        res[i] \u003D res[i \u002D 1] + res[i \u002D 2]\u003B\u000D\u000A                    } else {\u000D\u000A                        res[i] \u003D res[i \u002D 1]\u003B\u000D\u000A                    }\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res[res.length\u002D1]\u003B\u000D\u000A    }\u000D\u000A}';
Subsets II =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E subsetsWithDup(int[] array){\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        res.add(new ArrayList\u003CInteger\u003E())\u003B\u000D\u000A        if(array \u003D\u003D null || array.length \u003D\u003D 0)\u000D\u000A            return res\u003B\u000D\u000A        Arrays.sort(array)\u003B\u000D\u000A        int start \u003D 0\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Carray.length\u003Bi++){\u000D\u000A            int size \u003D res.size()\u003B\u000D\u000A            for(int j\u003Dstart\u003Bj\u003Csize\u003Bj++){\u000D\u000A                ArrayList\u003CInteger\u003E tmp \u003D new ArrayList\u003CInteger\u003E(res.get(j))\u003B\u000D\u000A                tmp.add(array[i])\u003B\u000D\u000A                res.add(tmp)\u003B\u000D\u000A            }\u000D\u000A            if(i\u003Carray.length\u002D1 \u0026\u0026 array[i] \u003D\u003D array[i+1])\u000D\u000A                start \u003D size\u003B\u000D\u000A            else\u000D\u000A                start \u003D 0\u003B\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Gray Code =>     scope.code.cpp = 'class Solution {\u000D\u000Apublic:\u000D\u000A     vector\u003Cint\u003E grayCode(int n) {  \u000D\u000A      // Start typing your C/C++ solution below  \u000D\u000A      // DO NOT write int main() function  \u000D\u000A      vector\u003Cint\u003E result\u003B      \u000D\u000A      result.push_back(0)\u003B  \u000D\u000A      for(int i\u003D0\u003B i\u003C n\u003B i++)  \u000D\u000A      {  \u000D\u000A        int highestBit \u003D 1\u003C\u003Ci\u003B  \u000D\u000A        int len \u003D result.size()\u003B  \u000D\u000A        for(int i \u003D len\u002D1\u003B i\u003E\u003D0\u003B i\u002D\u002D)  \u000D\u000A        {  \u000D\u000A          result.push_back(highestBit + result[i])\u003B  \u000D\u000A        }  \u000D\u000A      }  \u000D\u000A      return result\u003B  \u000D\u000A    }  \u000D\u000A}\u003B';
Merge Sorted Array =>     scope.code.java = 'public class Solution {\u000D\u000A    public void merge(int A[], int m, int B[], int n) {\u000D\u000A        if(n\u003D\u003D0)\u000D\u000A            return\u003B\u000D\u000A        if(m\u003D\u003D0){\u000D\u000A            for(int i\u003D0\u003Bi\u003Cn\u003Bi++)\u000D\u000A\u0009\u0009\u0009\u0009A[i] \u003D B[i]\u003B\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        int length \u003D m + n\u003B\u000D\u000A\u0009\u0009while(m !\u003D 0\u0026\u0026n !\u003D 0){\u000D\u000A\u0009\u0009\u0009if(A[m\u002D1]\u003E\u003DB[n\u002D1]){\u000D\u000A\u0009\u0009\u0009\u0009A[length\u002D1] \u003D A[m\u002D1]\u003B\u000D\u000A\u0009\u0009\u0009\u0009m\u002D\u002D\u003B\u000D\u000A\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009A[length\u002D1] \u003D B[n\u002D1]\u003B\u000D\u000A\u0009\u0009\u0009\u0009n\u002D\u002D\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009length\u002D\u002D\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(m!\u003D0){\u000D\u000A\u0009\u0009\u0009A[length\u002D1] \u003D A[m\u002D1]\u003B\u000D\u000A\u0009\u0009\u0009length\u002D\u002D\u003B\u000D\u000A\u0009\u0009\u0009m\u002D\u002D\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(n!\u003D0){\u000D\u000A\u0009\u0009\u0009A[length\u002D1] \u003D B[n\u002D1]\u003B\u000D\u000A\u0009\u0009\u0009n\u002D\u002D\u003B\u000D\u000A\u0009\u0009\u0009length\u002D\u002D\u003B\u000D\u000A\u0009\u0009}\u000D\u000A    }\u000D\u000A}';
Partition List =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode partition(ListNode head,int x){\u000D\u000A        ListNode firsthead \u003D new ListNode(0)\u003B\u000D\u000A        ListNode secondhead \u003D new ListNode(0)\u003B\u000D\u000A        ListNode p \u003D firsthead\u003B\u000D\u000A        ListNode q \u003D secondhead\u003B\u000D\u000A        ListNode r \u003D head\u003B\u000D\u000A        while(r!\u003Dnull){\u000D\u000A            if(r.val \u003C x){\u000D\u000A                p.next \u003D r\u003B\u000D\u000A                p \u003D r\u003B\u000D\u000A            }\u000D\u000A            else{\u000D\u000A                q.next \u003D r\u003B\u000D\u000A                q \u003D r\u003B\u000D\u000A            }\u000D\u000A            r \u003D r.next\u003B\u000D\u000A        }\u000D\u000A        q.next \u003D null\u003B\u000D\u000A        p.next \u003D secondhead.next\u003B\u000D\u000A        return firsthead.next\u003B\u000D\u000A    }\u000D\u000A}';
Maximal Rectangle =>     scope.code.java = 'public class Solution {\u000D\u000A     public int maximalRectangle(char[][] matrix){\u000D\u000A        if(matrix \u003D\u003D null || matrix.length \u003D\u003D 0 || matrix[0].length \u003D\u003D 0)\u000D\u000A            return 0\u003B\u000D\u000A        int m \u003D matrix.length\u003B\u000D\u000A        int n \u003D matrix[0].length\u003B\u000D\u000A        int maxArea \u003D 0\u003B\u000D\u000A        int[] height \u003D new int[n]\u003B\u000D\u000A        for (int i\u003D0\u003Bi\u003Cm\u003Bi++){\u000D\u000A            for (int j\u003D0\u003Bj\u003Cn\u003Bj++){\u000D\u000A                if (matrix[i][j] \u003D\u003D \u00270\u0027)\u000D\u000A                    height[j] \u003D 0\u003B\u000D\u000A                else\u000D\u000A                    height[j] +\u003D 1\u003B\u000D\u000A            }\u000D\u000A            maxArea \u003D Math.max(maxArea,largestRectangleArea(height))\u003B\u000D\u000A        }\u000D\u000A        return maxArea\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private int largestRectangleArea(int[] height) {\u000D\u000A        Stack\u003CInteger\u003E stack \u003D new Stack\u003CInteger\u003E()\u003B\u000D\u000A        int i \u003D 0\u003B\u000D\u000A        int maxArea \u003D 0\u003B\u000D\u000A        int[] h \u003D new int[height.length + 1]\u003B\u000D\u000A        h \u003D Arrays.copyOf(height, height.length + 1)\u003B\u000D\u000A        while(i \u003C h.length){\u000D\u000A            if(stack.isEmpty() || h[stack.peek()] \u003C\u003D h[i]){\u000D\u000A                stack.push(i++)\u003B\u000D\u000A            }else {\u000D\u000A                int t \u003D stack.pop()\u003B\u000D\u000A                maxArea \u003D Math.max(maxArea, h[t] * (stack.isEmpty() ? i : i \u002D stack.peek() \u002D 1))\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return maxArea\u003B\u000D\u000A    }\u000D\u000A}';
Largest Rectangle in Histogram =>     scope.code.java = 'public class Solution {\u000D\u000A    public int largestRectangleArea(int[] height) {\u000D\u000A    Stack\u003CInteger\u003E stack \u003D new Stack\u003CInteger\u003E()\u003B\u000D\u000A    int i \u003D 0\u003B\u000D\u000A    int maxArea \u003D 0\u003B\u000D\u000A    int[] h \u003D new int[height.length + 1]\u003B\u000D\u000A    h \u003D Arrays.copyOf(height, height.length + 1)\u003B\u000D\u000A    while(i \u003C h.length){\u000D\u000A        if(stack.isEmpty() || h[stack.peek()] \u003C\u003D h[i]){\u000D\u000A            stack.push(i++)\u003B\u000D\u000A        }else {\u000D\u000A            int t \u003D stack.pop()\u003B\u000D\u000A            maxArea \u003D Math.max(maxArea, h[t] * (stack.isEmpty() ? i : i \u002D stack.peek() \u002D 1))\u003B\u000D\u000A        }\u000D\u000A    }\u000D\u000A    return maxArea\u003B\u000D\u000A}\u000D\u000A}';
Largest Rectangle in Histogram =>     scope.code.java = 'public class Solution {\u000D\u000A    public int largestRectangleArea(int[] height) {\u000D\u000A        int maxArea \u003D 0\u003B\u000D\u000A        for (int i \u003D 0\u003B i \u003C height.length\u003B i++) {\u000D\u000A            if (i + 1 \u003C height.length \u0026\u0026 height[i] \u003C\u003D height[i + 1])\u000D\u000A                continue\u003B\u000D\u000A            int minHeight \u003D height[i]\u003B\u000D\u000A            for (int j \u003D i\u003B j \u003E\u003D 0\u003B j\u002D\u002D) {\u000D\u000A                minHeight \u003D Math.min(minHeight, height[j])\u003B\u000D\u000A                int area \u003D minHeight * (i \u002D j + 1)\u003B\u000D\u000A                if (area \u003E maxArea)\u000D\u000A                    maxArea \u003D area\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return maxArea\u003B\u000D\u000A    }\u000D\u000A}';
Remove Duplicates from Sorted List =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode deleteDuplicates(ListNode head) {\u000D\u000A        if(head \u003D\u003D null || head.next \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return head\u003B\u000D\u000A\u0009\u0009ListNode pre \u003D head\u003B\u000D\u000A\u0009\u0009ListNode p \u003D head.next\u003B\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009while(p!\u003Dnull){\u000D\u000A\u0009\u0009\u0009if(p.val \u003D\u003D pre.val){\u000D\u000A\u0009\u0009\u0009\u0009pre.next \u003D p.next\u003B\u000D\u000A\u0009\u0009\u0009\u0009p \u003D p.next\u003B\u000D\u000A\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009pre \u003D p\u003B\u000D\u000A\u0009\u0009\u0009\u0009p \u003D p.next\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return head\u003B\u000D\u000A    }\u000D\u000A}';
Remove Duplicates from Sorted List II =>     scope.code.python = '# Definition for singly\u002Dlinked list.\u000D\u000A# class ListNode:\u000D\u000A#     def __init__(self, x):\u000D\u000A#         self.val \u003D x\u000D\u000A#         self.next \u003D None\u000D\u000A\u000D\u000Aclass Solution:\u000D\u000A    def deleteDuplicates(self,head):\u000D\u000A        flagNode \u003D ListNode(3.14)\u000D\u000A        q \u003D head\u000D\u000A        preNode \u003D flagNode\u000D\u000A        headNode \u003D flagNode\u000D\u000A        while q !\u003D None:\u000D\u000A            if headNode.val !\u003D q.val:\u000D\u000A                headNode.next \u003D q\u000D\u000A                preNode \u003D headNode\u000D\u000A                headNode \u003D q\u000D\u000A            else:\u000D\u000A                while q !\u003D None and headNode.val \u003D\u003D q.val:\u000D\u000A                    q \u003D q.next\u000D\u000A                if q \u003D\u003D None:\u000D\u000A                    preNode.next \u003D q\u000D\u000A                    break\u000D\u000A                else:\u000D\u000A                    preNode.next \u003D q\u000D\u000A                    headNode \u003D q\u000D\u000A            q \u003D q.next\u000D\u000A        return flagNode.next\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A        ';
Search in Rotated Sorted Array II =>     scope.code.java = 'public class Solution {\u000D\u000A    public boolean search(int[] A, int target){\u000D\u000A        if(A \u003D\u003D null || A.length \u003D\u003D 0)\u000D\u000A            return false\u003B\u000D\u000A        int low \u003D 0\u003B\u000D\u000A        int high \u003D A.length\u002D1\u003B\u000D\u000A        while(low \u003C\u003D high){\u000D\u000A            int mid \u003D (low+high)/2\u003B\u000D\u000A            if(A[mid] \u003D\u003D target)\u000D\u000A                return true\u003B\u000D\u000A            if(A[mid] \u003E A[low]){\u000D\u000A                if (A[mid] \u003E target \u0026\u0026 A[low] \u003C\u003D target){\u000D\u000A                    high \u003D mid \u002D1\u003B\u000D\u000A                }\u000D\u000A                else {\u000D\u000A                    low \u003D mid + 1\u003B\u000D\u000A                }\u000D\u000A            }else if (A[mid] \u003C A[low]){\u000D\u000A                if(A[mid] \u003C target \u0026\u0026 A[high] \u003E\u003D target){\u000D\u000A                    low \u003D mid + 1\u003B\u000D\u000A                }else {\u000D\u000A                    high \u003D mid \u002D 1\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A            else {\u000D\u000A                low +\u003D 1\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return false\u003B\u000D\u000A    }\u000D\u000A}';
Remove Duplicates from Sorted Array II =>     scope.code.java = 'public class Solution {\u000D\u000A    public int removeDuplicates(int[] A){\u000D\u000A        if(A.length \u003C 3)\u000D\u000A            return A.length\u003B\u000D\u000A        int i\u003D0, j\u003D1,count \u003D 1\u003B\u000D\u000A        while(j\u003CA.length){\u000D\u000A            if(A[j] \u003D\u003D A[i]){\u000D\u000A                count +\u003D 1\u003B\u000D\u000A                if(count \u003C 3){\u000D\u000A                    A[++i] \u003D A[j]\u003B\u000D\u000A                    j++\u003B\u000D\u000A                }else{\u000D\u000A                    while(j\u003CA.length \u0026\u0026 A[j] \u003D\u003D A[i])\u000D\u000A                        j++\u003B\u000D\u000A                    if(j\u003CA.length) {\u000D\u000A                        A[++i] \u003D A[j]\u003B\u000D\u000A                        count \u003D 1\u003B\u000D\u000A                        j++\u003B\u000D\u000A                    }else{\u000D\u000A                        break\u003B\u000D\u000A                    }\u000D\u000A                }\u000D\u000A            }else{\u000D\u000A                count \u003D 1\u003B\u000D\u000A                A[++i] \u003D A[j]\u003B\u000D\u000A                j++\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return i+1\u003B\u000D\u000A    }\u000D\u000A}';
Word Search =>     scope.code.java = 'public class Solution {\u000D\u000A    boolean[][] visited\u003B\u000D\u000A    public boolean exist(char[][] board, String word) {\u000D\u000A        if (word.length() \u003D\u003D 0)\u000D\u000A            return true\u003B\u000D\u000A        int m \u003D board.length\u003B\u000D\u000A        int n \u003D board[0].length\u003B\u000D\u000A        visited \u003D new boolean[m][n]\u003B\u000D\u000A        for (int i \u003D 0\u003B i \u003C m\u003B i++) {\u000D\u000A            for (int j \u003D 0\u003B j \u003C n\u003B j++) {\u000D\u000A                if (search(board, word, 0, i, j))\u000D\u000A                    return true\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return false\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private boolean search(char[][] board, String word, int n, int i, int j) {\u000D\u000A        if (n \u003D\u003D word.length())\u000D\u000A            return true\u003B\u000D\u000A        if (i \u003C 0 || i \u003E\u003D board.length || j \u003C 0 || j \u003E\u003D board[0].length)\u000D\u000A            return false\u003B\u000D\u000A        if (visited[i][j])\u000D\u000A            return false\u003B\u000D\u000A        if (word.charAt(n) !\u003D board[i][j])\u000D\u000A            return false\u003B\u000D\u000A        visited[i][j] \u003D true\u003B\u000D\u000A        boolean result \u003D search(board, word, n + 1, i \u002D 1, j) || search(board, word, n + 1, i + 1, j) || search(board, word, n + 1, i, j \u002D 1) || search(board, word, n + 1, i, j + 1)\u003B\u000D\u000A        visited[i][j] \u003D false\u003B\u000D\u000A        return result\u003B\u000D\u000A    }\u000D\u000A}';
Subsets =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E subsets(int[] array){\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        res.add(new ArrayList\u003CInteger\u003E())\u003B\u000D\u000A        if(array \u003D\u003D null || array.length \u003D\u003D 0)\u000D\u000A            return res\u003B\u000D\u000A        Arrays.sort(array)\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Carray.length\u003Bi++){\u000D\u000A            int size \u003D res.size()\u003B\u000D\u000A            for(int j\u003D0\u003Bj\u003Csize\u003Bj++){\u000D\u000A                ArrayList\u003CInteger\u003E tmp \u003D new ArrayList\u003CInteger\u003E(res.get(j))\u003B\u000D\u000A                tmp.add(array[i])\u003B\u000D\u000A                res.add(tmp)\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Combinations =>     scope.code.python = 'class Solution:\u000D\u000A\u0009def combine(self,n,k):\u000D\u000A\u0009\u0009res \u003D []\u000D\u000A\u0009\u0009item \u003D []\u000D\u000A\u0009\u0009self.helper(n,k,item,res)\u000D\u000A\u0009\u0009return res\u000D\u000A\u0009def helper(self,n,k,item,res):\u000D\u000A\u0009\u0009if len(item) \u003D\u003D k:\u000D\u000A\u0009\u0009\u0009res.append(list(item))\u000D\u000A\u0009\u0009\u0009return\u000D\u000A\u0009\u0009for i in range(1,n+1):\u000D\u000A\u0009\u0009\u0009if len(item) \u003D\u003D 0 or i \u003E item[\u002D1]:\u000D\u000A\u0009\u0009\u0009\u0009item.append(i)\u000D\u000A\u0009\u0009\u0009\u0009self.helper(n,k,item,res)\u000D\u000A\u0009\u0009\u0009\u0009del item[\u002D1]';
Minimum Window Substring =>     scope.code.java = 'public class Solution {\u000D\u000A    public String minWindow(String S,String T){\u000D\u000A        if (S \u003D\u003D null || S.length() \u003D\u003D 0)\u000D\u000A            return \u0022\u0022\u003B\u000D\u000A        HashMap\u003CCharacter,Integer\u003E map \u003D new HashMap\u003CCharacter,Integer\u003E()\u003B\u000D\u000A        for (int i\u003D0\u003Bi\u003CT.length()\u003Bi++){\u000D\u000A            if (map.containsKey(T.charAt(i)))\u000D\u000A                map.put(T.charAt(i),map.get(T.charAt(i))+1)\u003B\u000D\u000A            else\u000D\u000A                map.put(T.charAt(i),1)\u003B\u000D\u000A        }\u000D\u000A        int left \u003D 0\u003B\u000D\u000A        int count \u003D 0\u003B\u000D\u000A        int minLen \u003D S.length() + 1\u003B\u000D\u000A        int minStart \u003D 0\u003B\u000D\u000A        for (int right \u003D 0\u003Bright\u003CS.length()\u003Bright++){\u000D\u000A            if (map.containsKey(S.charAt(right))){\u000D\u000A                map.put(S.charAt(right),map.get(S.charAt(right))\u002D1)\u003B\u000D\u000A                if (map.get(S.charAt(right)) \u003E\u003D 0)\u000D\u000A                    count++\u003B\u000D\u000A                while(count \u003D\u003D T.length())\u000D\u000A                {\u000D\u000A                    if(right\u002Dleft+1\u003CminLen)\u000D\u000A                    {\u000D\u000A                        minLen \u003D right\u002Dleft+1\u003B\u000D\u000A                        minStart \u003D left\u003B\u000D\u000A                    }\u000D\u000A                    if(map.containsKey(S.charAt(left)))\u000D\u000A                    {\u000D\u000A                        map.put(S.charAt(left), map.get(S.charAt(left))+1)\u003B\u000D\u000A                        if(map.get(S.charAt(left))\u003E0)\u000D\u000A                        {\u000D\u000A                            count\u002D\u002D\u003B\u000D\u000A                        }\u000D\u000A                    }\u000D\u000A                    left++\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        if(minLen\u003ES.length())\u000D\u000A        {\u000D\u000A            return \u0022\u0022\u003B\u000D\u000A        }\u000D\u000A        return S.substring(minStart,minStart+minLen)\u003B\u000D\u000A    }\u000D\u000A}';
Sort Colors =>     scope.code.python = 'class Solution:\u000D\u000A    def sortColors(self,A):\u000D\u000A        size \u003D len(A)\u000D\u000A        begin \u003D 0\u000D\u000A        end \u003D size \u002D 1\u000D\u000A        i \u003D 0\u000D\u000A        while i \u003C len(A):\u000D\u000A            if A[i] \u003D\u003D 0:\u000D\u000A                if i \u003D\u003D begin:\u000D\u000A                    i +\u003D 1\u000D\u000A                else:\u000D\u000A                    A[begin],A[i] \u003D A[i],A[begin]\u000D\u000A                begin +\u003D 1\u000D\u000A            elif A[i] \u003D\u003D 1:\u000D\u000A                i +\u003D 1\u000D\u000A            elif A[i] \u003D\u003D 2:\u000D\u000A                if i \u003E\u003D end:\u000D\u000A                    return\u000D\u000A                A[end],A[i] \u003D A[i],A[end]\u000D\u000A                end \u002D\u003D 1';
Search a 2D Matrix =>     scope.code.java = 'public class Solution {\u000D\u000A   public boolean searchMatrix(int[][] matrix, int target){\u000D\u000A        int rowLength \u003D matrix.length\u003B\u000D\u000A        int columLength \u003D matrix[0].length\u003B\u000D\u000A        int targetRow \u003D rowLength\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003CrowLength\u003Bi++){\u000D\u000A            if(matrix[i][columLength\u002D1] \u003E target){\u000D\u000A                targetRow \u003D i\u003B\u000D\u000A                break\u003B\u000D\u000A            }\u000D\u000A            if(matrix[i][columLength\u002D1] \u003D\u003D target)\u000D\u000A                return true\u003B\u000D\u000A        }\u000D\u000A        if(targetRow \u003D\u003D rowLength)\u000D\u000A            return false\u003B\u000D\u000A        int low\u003D0,high \u003D columLength\u002D1\u003B\u000D\u000A        while(low\u003C\u003Dhigh){\u000D\u000A            int mid \u003D (low+high)/2\u003B\u000D\u000A            if(matrix[targetRow][mid] \u003D\u003D target)\u000D\u000A                return true\u003B\u000D\u000A            else if(matrix[targetRow][mid]\u003Etarget){\u000D\u000A                high \u003D mid\u002D1\u003B\u000D\u000A            }\u000D\u000A            else\u000D\u000A                low \u003D mid + 1\u003B\u000D\u000A        }\u000D\u000A        return false\u003B\u000D\u000A    }\u000D\u000A}';
Set Matrix Zeroes =>     scope.code.python = 'class Solution:\u000D\u000A    # @param matrix, a list of lists of integers\u000D\u000A    # RETURN NOTHING, MODIFY matrix IN PLACE.\u000D\u000A    def setZeroes(self, matrix):\u000D\u000A        cols \u003D [False] * len(matrix[0])\u000D\u000A        rowLength \u003D len(matrix)\u000D\u000A        colLength \u003D len(matrix[0])\u000D\u000A        rowhasZero \u003D False\u000D\u000A        for i in range(rowLength):\u000D\u000A            for j in range(colLength):\u000D\u000A                if matrix[i][j] \u003D\u003D 0:\u000D\u000A                    rowhasZero \u003D True\u000D\u000A                    cols[j] \u003D True\u000D\u000A            if rowhasZero:\u000D\u000A                matrix[i] \u003D [0] * colLength\u000D\u000A                rowhasZero \u003D False\u000D\u000A        for  i in range(len(cols)):\u000D\u000A            if cols[i]:\u000D\u000A                for row in range(rowLength):\u000D\u000A                    matrix[row][i] \u003D 0\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A';
Edit Distance =>     scope.code.java = 'public class Solution {\u000D\u000A   public int minDistance(String word1,String word2){\u000D\u000A        int m \u003D word1.length()\u003B\u000D\u000A        int n \u003D word2.length()\u003B\u000D\u000A        int leftCell \u003D 0,rightCell \u003D 0, cornerCell \u003D 0\u003B\u000D\u000A        int[][] c \u003D new int[m+1][n+1]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003C\u003Dm\u003Bi++)\u000D\u000A            c[i][0] \u003D i\u003B\u000D\u000A        for(int j\u003D0\u003Bj\u003C\u003Dn\u003Bj++)\u000D\u000A            c[0][j] \u003D j\u003B\u000D\u000A        for(int i\u003D1\u003Bi\u003C\u003Dm\u003Bi++){\u000D\u000A            for(int j\u003D1\u003Bj\u003C\u003Dn\u003Bj++){\u000D\u000A                leftCell \u003D c[i][j\u002D1] + 1\u003B\u000D\u000A                rightCell \u003D c[i\u002D1][j] + 1\u003B\u000D\u000A                cornerCell \u003D c[i\u002D1][j\u002D1] + (word1.charAt(i\u002D1)\u003D\u003D word2.charAt(j\u002D1)? 0 : 1)\u003B\u000D\u000A                c[i][j] \u003D Math.min(Math.min(leftCell,rightCell),cornerCell)\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return c[m][n]\u003B\u000D\u000A   }\u000D\u000A}';
Simplify Path =>     scope.code.python = 'class Solution:\u000D\u000A    # @param path, a string\u000D\u000A    # @return a string\u000D\u000A def simplifyPath(self,path):\u000D\u000A    res\u003D[]\u000D\u000A    con \u003D re.split(\u0027(/)\u0027,path)\u000D\u000A    con \u003D [item for item in con if item !\u003D \u0022\u0022]\u000D\u000A    if len(con) \u003E\u003D 2 and con[\u002D1] \u003D\u003D \u0027/\u0027:\u000D\u000A      con \u003D con[:\u002D1]\u000D\u000A    for i in range(len(con)):\u000D\u000A      if con[i] \u003D\u003D \u0027/\u0027:\u000D\u000A        if i \u003E 0 and res[\u002D1] \u003D\u003D \u0027/\u0027:\u000D\u000A          next\u000D\u000A        else:\u000D\u000A          res.append(con[i])\u000D\u000A      elif con[i] \u003D\u003D \u0027.\u0027:\u000D\u000A        next\u000D\u000A      elif con[i] \u003D\u003D \u0027..\u0027:\u000D\u000A        if len(res) \u003E 2:\u000D\u000A          res.pop()\u000D\u000A          res.pop()\u000D\u000A      else:\u000D\u000A        res.append(con[i])\u000D\u000A    if len(res) \u003E\u003D 2 and res[\u002D1] \u003D\u003D \u0027/\u0027:\u000D\u000A        res \u003D res[:\u002D1]\u000D\u000A    return \u0022\u0022.join(res)\u000D\u000A        ';
Climbing Stairs =>     scope.code.java = 'public class Solution {\u000D\u000A    public int climbStairs(int n) {\u000D\u000A        int a \u003D 2,b \u003D 3,c \u003D 5\u003B\u000D\u000A\u0009\u0009if(n \u003C 4)\u000D\u000A\u0009\u0009\u0009return n\u003B\u000D\u000A\u0009\u0009for(int i\u003D4\u003B i\u003C\u003Dn\u003B i++){\u000D\u000A\u0009\u0009\u0009c \u003D a + b\u003B\u000D\u000A\u0009\u0009\u0009a \u003D b\u003B\u000D\u000A\u0009\u0009\u0009b \u003D c\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return c\u003B\u000D\u000A    }\u000D\u000A}';
Sqrt(x) =>     scope.code.java = 'public class Solution {\u000D\u000A    public int sqrt(int x){\u000D\u000A        int start \u003D 0\u003B\u000D\u000A        int end \u003D x/2 \u003C Math.sqrt(Integer.MAX_VALUE)? x/2+1 : (int)Math.sqrt(Integer.MAX_VALUE)\u003B\u000D\u000A        while(start \u003C\u003D end){\u000D\u000A            int mid \u003D (start+end)/2\u003B\u000D\u000A            int res \u003D mid * mid\u003B\u000D\u000A            if (res \u003D\u003D x)\u000D\u000A                return mid\u003B\u000D\u000A            else if (res \u003C x)\u000D\u000A                start \u003D mid + 1\u003B\u000D\u000A            else\u000D\u000A                end \u003D mid \u002D 1\u003B\u000D\u000A        }\u000D\u000A        return (start+end)/2\u003B\u000D\u000A    }\u000D\u000A}';
Add Binary =>     scope.code.java = 'public class Solution {\u000D\u000A    public String addBinary(String a, String b) {\u000D\u000A         int m \u003D a.length()\u003B\u000D\u000A        int n \u003D b.length()\u003B\u000D\u000A        int flag \u003D 0\u003B\u000D\u000A        StringBuilder sb \u003D new StringBuilder()\u003B\u000D\u000A        int commonLength \u003D m \u003C\u003D n? m : n\u003B\u000D\u000A        for(int count\u003D0, i\u003Da.length()\u002D1,j\u003Db.length()\u002D1\u003B count\u003CcommonLength\u003Bcount++,i\u002D\u002D,j\u002D\u002D){\u000D\u000A            int plus1 \u003D Character.getNumericValue(a.charAt(i))\u003B\u000D\u000A            int plus2 \u003D Character.getNumericValue(b.charAt(j))\u003B\u000D\u000A            int res \u003D plus1 + plus2+ flag\u003B\u000D\u000A            if(res \u003D\u003D 0){\u000D\u000A                sb.append(\u00220\u0022)\u003B\u000D\u000A                flag \u003D 0\u003B\u000D\u000A            }\u000D\u000A            else if(res \u003D\u003D 1){\u000D\u000A                sb.append(\u00221\u0022)\u003B\u000D\u000A                flag \u003D 0\u003B\u000D\u000A            }\u000D\u000A            else if(res \u003D\u003D 2){\u000D\u000A                sb.append(\u00220\u0022)\u003B\u000D\u000A                flag \u003D 1\u003B\u000D\u000A            }\u000D\u000A            else{\u000D\u000A                sb.append(\u00221\u0022)\u003B\u000D\u000A                flag \u003D 1\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        if(m\u003En){\u000D\u000A            for(int i\u003Dm\u002DcommonLength\u002D1\u003Bi\u003E\u003D0\u003Bi\u002D\u002D){\u000D\u000A                int res \u003D Character.getNumericValue(a.charAt(i))+flag\u003B\u000D\u000A                if(res \u003D\u003D 0 || res \u003D\u003D 1){\u000D\u000A                    flag \u003D 0\u003B\u000D\u000A                    sb.append(res)\u003B\u000D\u000A                }\u000D\u000A                if(res \u003D\u003D 2){\u000D\u000A                    flag \u003D  1\u003B\u000D\u000A                    sb.append(\u00220\u0022)\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        if(n\u003Em){\u000D\u000A            for(int i\u003Dn\u002DcommonLength\u002D1\u003Bi\u003E\u003D0\u003Bi\u002D\u002D){\u000D\u000A                int res \u003D Character.getNumericValue(b.charAt(i))+flag\u003B\u000D\u000A                if(res \u003D\u003D 0 || res \u003D\u003D 1){\u000D\u000A                    flag \u003D 0\u003B\u000D\u000A                    sb.append(res)\u003B\u000D\u000A                }\u000D\u000A                if(res \u003D\u003D 2){\u000D\u000A                    flag \u003D  1\u003B\u000D\u000A                    sb.append(\u00220\u0022)\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        if(flag \u003D\u003D 1)\u000D\u000A            sb.append(1)\u003B\u000D\u000A        return sb.reverse().toString()\u003B\u000D\u000A    }\u000D\u000A}';
Plus One =>     scope.code.java = 'public class Solution {\u000D\u000A    public int[] plusOne(int[] digits){\u000D\u000A\u0009\u0009int res \u003D 1\u003B\u000D\u000A\u0009\u0009for(int i\u003Ddigits.length\u002D1\u003Bi\u003E\u003D0\u003Bi\u002D\u002D){\u000D\u000A\u0009\u0009\u0009res +\u003D digits[i]\u003B\u000D\u000A\u0009\u0009\u0009digits[i] \u003D res % 10\u003B\u000D\u000A\u0009\u0009\u0009res /\u003D 10\u003B\u000D\u000A\u0009\u0009\u0009if(res \u003D\u003D 0)\u000D\u000A\u0009\u0009\u0009\u0009return digits\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009int[] new_digits \u003D new int[digits.length+1]\u003B\u000D\u000A\u0009\u0009for(int i\u003D1\u003Bi\u003Cnew_digits.length\u003Bi++){\u000D\u000A\u0009\u0009\u0009new_digits[i] \u003D digits[i\u002D1]\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009new_digits[0] \u003D 1\u003B\u000D\u000A\u0009\u0009return new_digits\u003B\u000D\u000A\u0009}\u000D\u000A}';
Valid Number =>     scope.code.java = 'public class Solution {\u000D\u000A    public boolean isNumber(String s) {\u000D\u000A        if(null\u003D\u003Ds)\u000D\u000A            return false\u003B\u000D\u000A        return s.matches(\u0022^\u005C\u005Cs*[\u005C\u005C+|\u005C\u005C\u002D]{0,1}[0\u002D9]*(([\u005C\u005C.]{0,1}[0\u002D9]+)|([0\u002D9]+[\u005C\u005C.]{0,1}))([e|E][\u005C\u005C+|\u005C\u005C\u002D]{0,1}[0\u002D9]+){0,1}\u005C\u005Cs*$\u0022)\u003B\u000D\u000A    }\u000D\u000A}';
Minimum Path Sum =>     scope.code.java = 'public class Solution {\u000D\u000A    public int minPathSum(int[][] grid){\u000D\u000A        int rowLength \u003D grid.length\u003B\u000D\u000A        int columLength \u003D grid[0].length\u003B\u000D\u000A        int[][] sumArray \u003D new int[rowLength][columLength]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003CrowLength\u003Bi++)\u000D\u000A            for(int j\u003D0\u003Bj\u003CcolumLength\u003Bj++)\u000D\u000A                sumArray[i][j] \u003D 0\u003B\u000D\u000A        sumArray[0][0] \u003D grid[0][0]\u003B\u000D\u000A        for(int i\u003D1\u003Bi\u003CcolumLength\u003Bi++)\u000D\u000A            sumArray[0][i] \u003D sumArray[0][i\u002D1] + grid[0][i]\u003B\u000D\u000A        for(int j\u003D1\u003Bj\u003CrowLength\u003Bj++)\u000D\u000A            sumArray[j][0] \u003D sumArray[j\u002D1][0] + grid[j][0]\u003B\u000D\u000A        for(int i\u003D1\u003Bi\u003CrowLength\u003Bi++){\u000D\u000A            for(int j\u003D1\u003Bj\u003CcolumLength\u003Bj++){\u000D\u000A                sumArray[i][j] \u003D Math.min(sumArray[i\u002D1][j],sumArray[i][j\u002D1]) + grid[i][j]\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return sumArray[rowLength\u002D1][columLength\u002D1]\u003B\u000D\u000A    }\u000D\u000A}';
Unique Paths II =>     scope.code.java = 'public class Solution {\u000D\u000A    public int uniquePathsWithObstacles(int[][] obstacleGrid){\u000D\u000A        if(obstacleGrid[0][0] \u003D\u003D 1)\u000D\u000A            return 0\u003B\u000D\u000A        int rowLength \u003D obstacleGrid.length\u003B\u000D\u000A        int columLength \u003D obstacleGrid[0].length\u003B\u000D\u000A        int[][] uniquePath \u003D new int[rowLength][columLength]\u003B\u000D\u000A        boolean obstacle \u003D false\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003CrowLength\u003Bi++){\u000D\u000A            if(obstacleGrid[i][0] \u003D\u003D 1){\u000D\u000A                obstacle \u003D true\u003B\u000D\u000A            }\u000D\u000A            if(obstacle)\u000D\u000A                uniquePath[i][0] \u003D 0\u003B\u000D\u000A            else\u000D\u000A                uniquePath[i][0] \u003D 1\u003B\u000D\u000A        }\u000D\u000A        obstacle \u003D false\u003B\u000D\u000A        for(int j\u003D0\u003Bj\u003CcolumLength\u003Bj++){\u000D\u000A            if(obstacleGrid[0][j] \u003D\u003D 1){\u000D\u000A                obstacle \u003D true\u003B\u000D\u000A            }\u000D\u000A            if(obstacle)\u000D\u000A                uniquePath[0][j] \u003D 0\u003B\u000D\u000A            else\u000D\u000A                uniquePath[0][j] \u003D 1\u003B\u000D\u000A        }\u000D\u000A        for(int i\u003D1\u003Bi\u003CrowLength\u003Bi++){\u000D\u000A            for(int j\u003D1\u003Bj\u003CcolumLength\u003Bj++){\u000D\u000A                if(obstacleGrid[i][j] \u003D\u003D 1)\u000D\u000A                    uniquePath[i][j] \u003D 0\u003B\u000D\u000A                else\u000D\u000A                    uniquePath[i][j] \u003D uniquePath[i][j\u002D1] + uniquePath[i\u002D1][j]\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return uniquePath[rowLength\u002D1][columLength\u002D1]\u003B\u000D\u000A    }\u000D\u000A}';
Unique Paths =>     scope.code.java = 'public class Solution {\u000D\u000A    public int uniquePaths(int m,int n){\u000D\u000A        int[][] uniquePath \u003D new int[m][n]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cm\u003Bi++){\u000D\u000A            uniquePath[i][0] \u003D 1\u003B\u000D\u000A        }\u000D\u000A        for(int j\u003D0\u003Bj\u003Cn\u003Bj++){\u000D\u000A            uniquePath[0][j] \u003D 1\u003B\u000D\u000A        }\u000D\u000A        for(int i\u003D1\u003Bi\u003Cm\u003Bi++){\u000D\u000A            for(int j\u003D1\u003Bj\u003Cn\u003Bj++){\u000D\u000A                uniquePath[i][j] \u003D uniquePath[i][j\u002D1] + uniquePath[i\u002D1][j]\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return uniquePath[m\u002D1][n\u002D1]\u003B\u000D\u000A    }\u000D\u000A}';
Rotate List =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode rotateRight(ListNode head, int n) {\u000D\u000A        if(head \u003D\u003D null || n \u003D\u003D 0)\u000D\u000A            return head\u003B\u000D\u000A        ListNode p \u003D head\u003B\u000D\u000A        int len \u003D 1\u003B\u000D\u000A        while(p.next !\u003D null){\u000D\u000A            p \u003D p.next\u003B\u000D\u000A            len +\u003D 1\u003B\u000D\u000A        }\u000D\u000A        n \u003D len \u002D n%len\u003B\u000D\u000A        p.next \u003D head\u003B\u000D\u000A        int step \u003D 0\u003B\u000D\u000A        while(step\u003Cn){\u000D\u000A            p \u003D p.next\u003B\u000D\u000A            step++\u003B\u000D\u000A        }\u000D\u000A        head \u003D p.next\u003B\u000D\u000A        p.next \u003D null\u003B\u000D\u000A        return head\u003B\u000D\u000A    }\u000D\u000A}';
Permutation Sequence =>     scope.code.python = 'class Solution:\u000D\u000A    def getPermutation(self,n,k):\u000D\u000A\u0009    fac \u003D []\u000D\u000A\u0009    res \u003D []\u000D\u000A\u0009    num \u003D []\u000D\u000A\u0009    fac.append(1)\u000D\u000A\u0009    for i in range(1,n):\u000D\u000A\u0009\u0009    fac.append(i* fac[i\u002D1])\u000D\u000A\u0009    for i in range(1,n+1):\u000D\u000A\u0009\u0009    num.append(i)\u000D\u000A\u0009    k \u002D\u003D 1\u000D\u000A\u0009    for i in range(n):\u000D\u000A\u0009\u0009\u0009res.append(num[k/fac[n\u002Di\u002D1]])\u000D\u000A\u0009\u0009\u0009del num[k/fac[n\u002Di\u002D1]]\u000D\u000A\u0009\u0009\u0009k \u003D k % fac[n\u002Di\u002D1]\u000D\u000A\u0009    return \u0022\u0022.join(\u0022%s\u0022 % (k) for k in res)\u000D\u000A\u000D\u000A\u000D\u000A        ';
Spiral Matrix II =>     scope.code.java = 'public class Solution {\u000D\u000A    public int[][] generateMatrix(int n) {\u000D\u000A        int[][] matrix \u003D new int[n][n]\u003B\u000D\u000A        int row \u003D n\u003B\u000D\u000A        int col \u003D n\u003B\u000D\u000A\u000D\u000A        int x\u003D0\u003B\u000D\u000A        int y\u003D0\u003B\u000D\u000A        int count \u003D 0\u003B\u000D\u000A\u000D\u000A        while(row\u003E0\u0026\u0026col\u003E0){\u000D\u000A            if(row \u003D\u003D 1){\u000D\u000A                for(int i\u003D0\u003Bi\u003Ccol\u003Bi++)\u000D\u000A                    matrix[x][y++] \u003D ++count\u003B\u000D\u000A                break\u003B\u000D\u000A            }\u000D\u000A\u000D\u000A            for (int i\u003D0\u003Bi\u003Ccol\u002D1\u003Bi++)\u000D\u000A                matrix[x][y++] \u003D ++count\u003B\u000D\u000A\u000D\u000A            for (int i\u003D0\u003Bi\u003Crow\u002D1\u003Bi++)\u000D\u000A                matrix[x++][y] \u003D ++count\u003B\u000D\u000A\u000D\u000A            for (int i\u003D0\u003Bi\u003Ccol\u002D1\u003Bi++)\u000D\u000A                matrix[x][y\u002D\u002D] \u003D ++count\u003B\u000D\u000A\u000D\u000A            for (int i\u003D0\u003Bi\u003Crow\u002D1\u003Bi++)\u000D\u000A                matrix[x\u002D\u002D][y] \u003D ++count\u003B\u000D\u000A\u000D\u000A            x++\u003B\u000D\u000A            y++\u003B\u000D\u000A            row \u002D\u003D 2\u003B\u000D\u000A            col \u002D\u003D 2\u003B\u000D\u000A        }\u000D\u000A        return matrix\u003B\u000D\u000A    }\u000D\u000A}';
Length of Last Word =>     scope.code.java = 'public class Solution {\u000D\u000A    public int lengthOfLastWord(String s) {\u000D\u000A        String[] array \u003D s.split(\u0022 \u0022)\u003B\u000D\u000A        if(array.length \u003D\u003D 0)\u000D\u000A\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009String last \u003D array[array.length\u002D1]\u003B\u000D\u000A\u0009\u0009return last.length()\u003B\u000D\u000A    }\u000D\u000A}';
Insert Interval =>     scope.code.python = '# Definition for an interval.\u000D\u000A# class Interval:\u000D\u000A#     def __init__(self, s\u003D0, e\u003D0):\u000D\u000A#         self.start \u003D s\u000D\u000A#         self.end \u003D e\u000D\u000A\u000D\u000Aclass Solution:\u000D\u000A  def insert(self,intervals,newInterval):\u000D\u000A    length \u003D len(intervals)\u000D\u000A\u000D\u000A    if length \u003D\u003D 0:\u000D\u000A      intervals.append(newInterval)\u000D\u000A      return intervals\u000D\u000A\u000D\u000A    idx \u003D \u002D1\u000D\u000A    for i in range(length):\u000D\u000A      if intervals[i].start \u003E\u003D newInterval.start:\u000D\u000A        idx \u003D i\u000D\u000A        break\u000D\u000A    if idx \u003D\u003D \u002D1:\u000D\u000A      intervals.append(newInterval)\u000D\u000A    else:\u000D\u000A      intervals.insert(idx,newInterval)\u000D\u000A\u000D\u000A    res \u003D []\u000D\u000A    for item in intervals:\u000D\u000A        if len(res) \u003D\u003D 0:\u000D\u000A            res.append(item)\u000D\u000A        if item.start \u003C\u003D res[\u002D1].end:\u000D\u000A            if item.end \u003E\u003D res[\u002D1].end:\u000D\u000A                res[\u002D1].end \u003D item.end\u000D\u000A            else:\u000D\u000A                continue\u000D\u000A        else:\u000D\u000A            res.append(item)\u000D\u000A    return res\u000D\u000A\u000D\u000A        ';
Merge Intervals =>     scope.code.python = '# Definition for an interval.\u000D\u000A# class Interval:\u000D\u000A#     def __init__(self, s\u003D0, e\u003D0):\u000D\u000A#         self.start \u003D s\u000D\u000A#         self.end \u003D e\u000D\u000A\u000D\u000Aclass Solution:\u000D\u000A    def merge(self,intervals):\u000D\u000A        intervals.sort(lambda x,y: cmp(x.start,y.start) if x.start !\u003D y.start else cmp(x.end,y.end))\u000D\u000A        res \u003D []\u000D\u000A        for item in intervals:\u000D\u000A            if len(res) \u003D\u003D 0:\u000D\u000A                res.append(item)\u000D\u000A            if item.start \u003C\u003D res[\u002D1].end:\u000D\u000A                if item.end \u003E\u003D res[\u002D1].end:\u000D\u000A                    res[\u002D1].end \u003D item.end\u000D\u000A                else:\u000D\u000A                    continue\u000D\u000A            else:\u000D\u000A                res.append(item)\u000D\u000A        return res\u000D\u000A';
Jump Game =>     scope.code.java = 'public class Solution {\u000D\u000A    public boolean canJump(int[] A) {\u000D\u000A        int reach \u003D 0\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003C\u003Dreach\u0026\u0026i\u003CA.length\u003Bi++){\u000D\u000A            reach \u003D Math.max(i+A[i],reach)\u003B\u000D\u000A        }\u000D\u000A        if(reach \u003C A.length\u002D1)\u000D\u000A            return false\u003B\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A}';
Spiral Matrix =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CInteger\u003E spiralOrder(int[][] matrix) {\u000D\u000A        ArrayList\u003CInteger\u003E res \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        if (matrix \u003D\u003D null || matrix.length \u003D\u003D 0)\u000D\u000A            return res\u003B\u000D\u000A        int m \u003D matrix.length\u003B\u000D\u000A        int n \u003D matrix[0].length\u003B\u000D\u000A\u000D\u000A        int x\u003D0\u003B\u000D\u000A        int y\u003D0\u003B\u000D\u000A\u000D\u000A        while(m\u003E0\u0026\u0026n\u003E0){\u000D\u000A            if(m \u003D\u003D 1){\u000D\u000A                for(int i\u003D0\u003Bi\u003Cn\u003Bi++)\u000D\u000A                    res.add(matrix[x][y++])\u003B\u000D\u000A                break\u003B\u000D\u000A            } else if (n \u003D\u003D 1){\u000D\u000A                for (int i\u003D0\u003Bi\u003Cm\u003Bi++)\u000D\u000A                    res.add(matrix[x++][y])\u003B\u000D\u000A                break\u003B\u000D\u000A            }\u000D\u000A\u000D\u000A            for (int i\u003D0\u003Bi\u003Cn\u002D1\u003Bi++)\u000D\u000A                res.add(matrix[x][y++])\u003B\u000D\u000A\u000D\u000A            for (int i\u003D0\u003Bi\u003Cm\u002D1\u003Bi++)\u000D\u000A                res.add(matrix[x++][y])\u003B\u000D\u000A\u000D\u000A            for (int i\u003D0\u003Bi\u003Cn\u002D1\u003Bi++)\u000D\u000A                res.add(matrix[x][y\u002D\u002D])\u003B\u000D\u000A\u000D\u000A            for (int i\u003D0\u003Bi\u003Cm\u002D1\u003Bi++)\u000D\u000A                res.add(matrix[x\u002D\u002D][y])\u003B\u000D\u000A\u000D\u000A            x++\u003B\u000D\u000A            y++\u003B\u000D\u000A            m \u002D\u003D 2\u003B\u000D\u000A            n \u002D\u003D 2\u003B\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Maximum Subarray =>     scope.code.java = 'public class Solution {\u000D\u000A    public int maxSubArray(int[] A) {\u000D\u000A        int max \u003D Integer.MIN_VALUE\u003B\u000D\u000A\u0009\u0009int current_sum \u003D 0\u003B\u000D\u000A\u0009\u0009if(A.length \u003D\u003D 1)\u000D\u000A\u0009\u0009\u0009return A[0]\u003B\u000D\u000A\u0009\u0009for(int i\u003D0\u003B i\u003CA.length\u003B i++){\u000D\u000A\u0009\u0009\u0009current_sum +\u003D A[i]\u003B\u000D\u000A\u0009\u0009\u0009if(current_sum \u003E max)\u000D\u000A\u0009\u0009\u0009\u0009max \u003D current_sum\u003B\u000D\u000A\u0009\u0009\u0009if(current_sum \u003C 0)\u000D\u000A\u0009\u0009\u0009\u0009current_sum \u003D 0\u003B\u000D\u000A\u0009\u0009\u0009\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return max\u003B\u000D\u000A    }\u000D\u000A}';
N-Queens II =>     scope.code.java = 'public class Solution {\u000D\u000A    public int totalNQueens(int n) {\u000D\u000A        int[] res \u003D {0}\u003B\u000D\u000A        helper(n,0,new int[n], res)\u003B\u000D\u000A        return res[0]\u003B\u000D\u000A    }\u000D\u000A    private void helper(int n, int row, int[] columnForRow, int [] res)\u000D\u000A{\u000D\u000A    if(row \u003D\u003D n){\u000D\u000A        res[0] +\u003D 1\u003B\u000D\u000A        return\u003B\u000D\u000A    }\u000D\u000A    for(int i\u003D0\u003Bi\u003Cn\u003Bi++)\u000D\u000A    {\u000D\u000A        columnForRow[row] \u003D i\u003B\u000D\u000A        if(check(row,columnForRow))\u000D\u000A        {\u000D\u000A            helper(n,row+1,columnForRow,res)\u003B\u000D\u000A        }\u000D\u000A    }\u000D\u000A}\u000D\u000Aprivate boolean check(int row, int[] columnForRow)\u000D\u000A{\u000D\u000A    for(int i\u003D0\u003Bi\u003Crow\u003Bi++)\u000D\u000A    {\u000D\u000A        if(columnForRow[row]\u003D\u003DcolumnForRow[i] || Math.abs(columnForRow[row]\u002DcolumnForRow[i])\u003D\u003Drow\u002Di)\u000D\u000A            return false\u003B\u000D\u000A    }\u000D\u000A    return true\u003B\u000D\u000A}\u000D\u000A}';
N-Queens =>     scope.code.java = 'public class Solution {\u000D\u000A     public ArrayList\u003CString[]\u003E solveNQueens(int n) {\u000D\u000A    ArrayList\u003CString[]\u003E res \u003D new ArrayList\u003CString[]\u003E()\u003B\u000D\u000A    helper(n,0,new int[n], res)\u003B\u000D\u000A    return res\u003B\u000D\u000A}\u000D\u000Aprivate void helper(int n, int row, int[] columnForRow, ArrayList\u003CString[]\u003E res)\u000D\u000A{\u000D\u000A    if(row \u003D\u003D n)\u000D\u000A    {\u000D\u000A        String[] item \u003D new String[n]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cn\u003Bi++)\u000D\u000A        {\u000D\u000A            StringBuilder strRow \u003D new StringBuilder()\u003B\u000D\u000A            for(int j\u003D0\u003Bj\u003Cn\u003Bj++)\u000D\u000A            {\u000D\u000A                if(columnForRow[i]\u003D\u003Dj)\u000D\u000A                    strRow.append(\u0027Q\u0027)\u003B\u000D\u000A                else\u000D\u000A                    strRow.append(\u0027.\u0027)\u003B\u000D\u000A            }\u000D\u000A            item[i] \u003D strRow.toString()\u003B\u000D\u000A        }\u000D\u000A        res.add(item)\u003B\u000D\u000A        return\u003B\u000D\u000A    }\u000D\u000A    for(int i\u003D0\u003Bi\u003Cn\u003Bi++)\u000D\u000A    {\u000D\u000A        columnForRow[row] \u003D i\u003B\u000D\u000A        if(check(row,columnForRow))\u000D\u000A        {\u000D\u000A            helper(n,row+1,columnForRow,res)\u003B\u000D\u000A        }\u000D\u000A    }\u000D\u000A}\u000D\u000Aprivate boolean check(int row, int[] columnForRow)\u000D\u000A{\u000D\u000A    for(int i\u003D0\u003Bi\u003Crow\u003Bi++)\u000D\u000A    {\u000D\u000A        if(columnForRow[row]\u003D\u003DcolumnForRow[i] || Math.abs(columnForRow[row]\u002DcolumnForRow[i])\u003D\u003Drow\u002Di)\u000D\u000A            return false\u003B\u000D\u000A    }\u000D\u000A    return true\u003B\u000D\u000A}\u000D\u000A}';
Pow(x, n) =>     scope.code.java = 'public class Solution {\u000D\u000A    public double pow(double x,int n){\u000D\u000A        if(n \u003C 0)\u000D\u000A            return 1/power(x,\u002Dn)\u003B\u000D\u000A        else\u000D\u000A            return power(x,n)\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private double power(double x, int n){\u000D\u000A        if(n\u003D\u003D0)\u000D\u000A            return 1\u003B\u000D\u000A        double v \u003D power(x,n/2)\u003B\u000D\u000A        if(n % 2 \u003D\u003D 0)\u000D\u000A            return v*v\u003B\u000D\u000A        else\u000D\u000A            return v*x*v\u003B\u000D\u000A    }\u000D\u000A}';
Anagrams =>     scope.code.python = 'class Solution:\u000D\u000A    def anagrams(self,strs):\u000D\u000A        dic \u003D {}\u000D\u000A        res \u003D []\u000D\u000A        for s in strs:\u000D\u000A            sorteds \u003D \u0027\u0027.join(sorted(s))\u000D\u000A            dic[sorteds] \u003D [s] if sorteds not in dic else dic[sorteds] + [s]\u000D\u000A        for item in dic:\u000D\u000A            if len(dic[item]) \u003E\u003D 2:\u000D\u000A                res +\u003D dic[item]\u000D\u000A        return res\u000D\u000A';
Anagrams =>     scope.code.java = 'public class Solution {\u000D\u000A    public List\u003CString\u003E anagrams(String[] strs) {\u000D\u000A        List\u003CString\u003E res \u003D new ArrayList\u003CString\u003E()\u003B\u000D\u000A        HashMap\u003CString,List\u003CString\u003E\u003E tmp \u003D new HashMap\u003CString, List\u003CString\u003E\u003E()\u003B\u000D\u000A        for(String t : strs){\u000D\u000A            char[] ch \u003D t.toCharArray()\u003B\u000D\u000A            Arrays.sort(ch)\u003B\u000D\u000A            String s \u003D String.valueOf(ch)\u003B\u000D\u000A            if (tmp.containsKey(s))\u000D\u000A                tmp.get(s).add(t)\u003B\u000D\u000A            else{\u000D\u000A                List\u003CString\u003E ls \u003D new ArrayList\u003CString\u003E()\u003B\u000D\u000A                ls.add(t)\u003B\u000D\u000A                tmp.put(s,ls)\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        Iterator iterator \u003D tmp.values().iterator()\u003B\u000D\u000A        while(iterator.hasNext()){\u000D\u000A            ArrayList\u003CString\u003E item \u003D (ArrayList\u003CString\u003E)iterator.next()\u003B\u000D\u000A            if(item.size()\u003E1)\u000D\u000A                res.addAll(item)\u003B\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A        \u000D\u000A    }\u000D\u000A}';
Rotate Image =>     scope.code.java = 'public class Solution {\u000D\u000A    public void rotate(int[][] matrix){\u000D\u000A        for(int i\u003D0\u003Bi\u003Cmatrix.length\u003Bi++)\u000D\u000A            for(int j\u003Di+1\u003Bj\u003Cmatrix.length\u003Bj++){\u000D\u000A                int tmp \u003D matrix[i][j]\u003B\u000D\u000A                matrix[i][j] \u003D matrix[j][i]\u003B\u000D\u000A                matrix[j][i] \u003D tmp\u003B\u000D\u000A            }\u000D\u000A        for(int i\u003D0,j\u003Dmatrix.length\u002D1\u003Bi\u003Cj\u003Bi++,j\u002D\u002D){\u000D\u000A            for(int m\u003D0\u003Bm\u003Cmatrix.length\u003Bm++){\u000D\u000A                int temp \u003D matrix[m][i]\u003B\u000D\u000A                matrix[m][i] \u003D matrix[m][j]\u003B\u000D\u000A                matrix[m][j] \u003D temp\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A    }\u000D\u000A}';
Permutations II =>     scope.code.python = 'class Solution:\u000D\u000A    # @return a list of lists of integers\u000D\u000A    def permuteUnique(self, num):\u000D\u000A    \u0009num \u003D sorted(num)\u000D\u000A    \u0009used \u003D [False] * len(num)\u000D\u000A    \u0009res \u003D []\u000D\u000A    \u0009item \u003D []\u000D\u000A    \u0009self.helper(num,used,item,res)\u000D\u000A    \u0009return res\u000D\u000A\u000D\u000A    def helper(self,num,used,item,res):\u000D\u000A    \u0009if len(item) \u003D\u003D len(num):\u000D\u000A    \u0009\u0009res.append(list(item))\u000D\u000A    \u0009\u0009return\u000D\u000A    \u0009for i in range(len(num)):\u000D\u000A    \u0009\u0009if not used[i]:\u000D\u000A    \u0009\u0009\u0009if i \u003E 0 and num[i] \u003D\u003D num[i\u002D1] and not used[i\u002D1]:\u000D\u000A    \u0009\u0009\u0009\u0009continue\u000D\u000A    \u0009\u0009\u0009used[i] \u003D True\u000D\u000A    \u0009\u0009\u0009item.append(num[i])\u000D\u000A    \u0009\u0009\u0009self.helper(num,used,item,res)\u000D\u000A    \u0009\u0009\u0009del item[\u002D1]\u000D\u000A    \u0009\u0009\u0009used[i] \u003D False';
Permutations =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E permute(int[] num) {\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(num \u003D\u003D null || num.length \u003D\u003D 0)\u000D\u000A            return res\u003B\u000D\u000A        boolean[] used \u003D new boolean[num.length]\u003B\u000D\u000A        ArrayList\u003CInteger\u003E item \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        helper(num,used,item,res)\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A    \u000D\u000A    private void helper(int[] num, boolean[] used,ArrayList\u003CInteger\u003Eitem,ArrayList\u003CArrayList\u003CInteger\u003E\u003E res){\u000D\u000A        if(item.size() \u003D\u003D num.length){\u000D\u000A            res.add(new ArrayList\u003CInteger\u003E(item))\u003B\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        for(int i\u003D0\u003Bi\u003Cnum.length\u003Bi++){\u000D\u000A            if(!used[i]){\u000D\u000A                item.add(num[i])\u003B\u000D\u000A                used[i] \u003D true\u003B\u000D\u000A                helper(num,used,item,res)\u003B\u000D\u000A                item.remove(item.size()\u002D1)\u003B\u000D\u000A                used[i] \u003D false\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A    }\u000D\u000A}';
Jump Game II =>     scope.code.java = 'public class Solution {\u000D\u000A    public int jump(int[] A){\u000D\u000A        if(A \u003D\u003D null || A.length \u003D\u003D 0)\u000D\u000A            return 0\u003B\u000D\u000A        int lastReach \u003D 0\u003B\u000D\u000A        int reach \u003D 0\u003B\u000D\u000A        int step \u003D 0\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003C\u003Dreach\u0026\u0026i\u003CA.length\u003Bi++){\u000D\u000A            if(i\u003ElastReach){\u000D\u000A                step++\u003B\u000D\u000A                lastReach \u003D reach\u003B\u000D\u000A            }\u000D\u000A            reach \u003D Math.max(reach,i+A[i])\u003B\u000D\u000A        }\u000D\u000A        if(reach\u003CA.length\u002D1)\u000D\u000A            return 0\u003B\u000D\u000A        return step\u003B\u000D\u000A    }\u000D\u000A}';
Multiply Strings =>     scope.code.python = 'class Solution:\u000D\u000A    def multiply(self,num1,num2):\u000D\u000A        if num1 \u003D\u003D \u00220\u0022 or num2 \u003D\u003D \u00220\u0022:\u000D\u000A            return \u00220\u0022\u000D\u000A        size \u003D len(num1) + len(num2) \u002D 1\u000D\u000A        res \u003D [0] * size\u000D\u000A        size1 \u003D len(num1)\u000D\u000A        size2 \u003D len(num2)\u000D\u000A        for i in range(size1):\u000D\u000A            for j in range(size2):\u000D\u000A                tmp \u003D int(num2[size2\u002Dj\u002D1]) * int(num1[size1\u002Di\u002D1])\u000D\u000A                res[size\u002Di\u002Dj\u002D1] +\u003D tmp\u000D\u000A        for i in range(size):\u000D\u000A            if i !\u003D 0:\u000D\u000A                tmp \u003D res[size\u002Di] / 10\u000D\u000A                res[size\u002Di\u002D1] +\u003D tmp\u000D\u000A                res[size\u002Di] %\u003D 10\u000D\u000A        res \u003D [str(item) for item in res]\u000D\u000A        return \u0022\u0022.join(res)\u000D\u000A';
Trapping Rain Water =>     scope.code.python = 'class Solution:\u000D\u000A    # @param A, a list of integers\u000D\u000A    # @return an integer\u000D\u000A    def trap(slef,A):\u000D\u000A        l \u003D [0] * len(A)\u000D\u000A        tmpmax \u003D 0\u000D\u000A        res \u003D 0\u000D\u000A        for i in range(len(A)):\u000D\u000A            l[i] \u003D tmpmax\u000D\u000A            tmpmax \u003D tmpmax if tmpmax \u003E A[i] else A[i]\u000D\u000A        tmpmax \u003D 0\u000D\u000A        for j in range(len(A)\u002D1,\u002D1,\u002D1):\u000D\u000A            topheight \u003D min(tmpmax,l[j])\u000D\u000A            tmpmax \u003D tmpmax if tmpmax \u003E A[j] else A[j]\u000D\u000A            if topheight \u003C\u003D A[j]:\u000D\u000A                continue\u000D\u000A            else:\u000D\u000A                res +\u003D topheight \u002D A[j]\u000D\u000A        return res\u000D\u000A\u000D\u000A        ';
First Missing Positive =>     scope.code.java = 'public class Solution {\u000D\u000A    public int firstMissingPositive(int[] A) {\u000D\u000A        int res \u003D 1\u003B\u000D\u000A\u0009\u0009Set\u003CInteger\u003E tmp \u003D new HashSet\u003CInteger\u003E()\u003B\u000D\u000A\u0009\u0009for(int i : A){\u000D\u000A\u0009\u0009\u0009if(i\u003E0)\u000D\u000A\u0009\u0009\u0009\u0009tmp.add(i)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009for(int i\u003D1\u003B i\u003CInteger.MAX_VALUE\u003Bi++){\u000D\u000A\u0009\u0009\u0009if(!tmp.contains(i)){\u000D\u000A\u0009\u0009\u0009\u0009res \u003D i\u003B\u000D\u000A\u0009\u0009\u0009\u0009break\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return res\u003B\u000D\u000A    }\u000D\u000A}';
First Missing Positive =>     scope.code.java = 'public class Solution {\u000D\u000A    public int firstMissingPositive(int[] A) {\u000D\u000A        int res \u003D 1\u003B\u000D\u000A\u0009\u0009Set\u003CInteger\u003E tmp \u003D new HashSet\u003CInteger\u003E()\u003B\u000D\u000A\u0009\u0009for(int i : A){\u000D\u000A\u0009\u0009\u0009if(i\u003E0)\u000D\u000A\u0009\u0009\u0009\u0009tmp.add(i)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009for(int i\u003D1\u003B i\u003CInteger.MAX_VALUE\u003Bi++){\u000D\u000A\u0009\u0009\u0009if(!tmp.contains(i)){\u000D\u000A\u0009\u0009\u0009\u0009res \u003D i\u003B\u000D\u000A\u0009\u0009\u0009\u0009break\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return res\u003B\u000D\u000A    }\u000D\u000A}';
Combination Sum II =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E combinationSum2(int[] num,int target){\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(num \u003D\u003D null || num.length \u003D\u003D 0)\u000D\u000A            return res\u003B\u000D\u000A        ArrayList\u003CInteger\u003E item \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        Arrays.sort(num)\u003B\u000D\u000A        helper(num, target, 0, item, res)\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A    private void helper(int[] num,int target,int start,ArrayList\u003CInteger\u003E item,ArrayList\u003CArrayList\u003CInteger\u003E\u003E res){\u000D\u000A        if(target \u003D\u003D 0){\u000D\u000A            res.add(new ArrayList\u003CInteger\u003E(item))\u003B\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        if(target \u003C 0 || start \u003E\u003D num.length)\u000D\u000A            return\u003B\u000D\u000A        for(int i\u003Dstart\u003Bi\u003Cnum.length\u003Bi++){\u000D\u000A            if(i\u003Estart \u0026\u0026 num[i] \u003D\u003D num[i\u002D1])\u000D\u000A                continue\u003B\u000D\u000A            item.add(num[i])\u003B\u000D\u000A            helper(num, target \u002D num[i], i + 1, item, res)\u003B\u000D\u000A            item.remove(item.size()\u002D1)\u003B\u000D\u000A        }\u000D\u000A    }\u000D\u000A}';
Combination Sum =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E combinationSum(int[] candidates, int target){\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(candidates.length \u003D\u003D 0 || candidates \u003D\u003D null)\u000D\u000A            return res\u003B\u000D\u000A        Arrays.sort(candidates)\u003B\u000D\u000A        ArrayList\u003CInteger\u003E item \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        helper(candidates,target,0,item,res)\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A    private void helper(int[] candidates,int target,int start,ArrayList\u003CInteger\u003E item, ArrayList\u003CArrayList\u003CInteger\u003E\u003E res){\u000D\u000A        if(sum(item) \u003D\u003D target){\u000D\u000A            res.add(new ArrayList\u003CInteger\u003E(item))\u003B\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        if(sum(item) \u003E target)\u000D\u000A            return\u003B\u000D\u000A        for(int i\u003Dstart\u003Bi\u003Ccandidates.length\u003Bi++){\u000D\u000A            if(i\u003E0 \u0026\u0026 candidates[i] \u003D\u003D candidates[i\u002D1])\u000D\u000A                continue\u003B\u000D\u000A            item.add(candidates[i])\u003B\u000D\u000A            helper(candidates,target,i,item,res)\u003B\u000D\u000A            item.remove(item.size()\u002D1)\u003B\u000D\u000A        }\u000D\u000A    }\u000D\u000A    private int sum(ArrayList\u003CInteger\u003E item){\u000D\u000A        int res \u003D 0\u003B\u000D\u000A        if(item !\u003D null)\u000D\u000A            for(int i : item)\u000D\u000A                res +\u003D i\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Count and Say =>     scope.code.java = 'public class Solution {\u000D\u000A    public String countAndSay(int n){\u000D\u000A        if(n \u003D\u003D 0)\u000D\u000A            return \u0022\u0022\u003B\u000D\u000A        String curRes \u003D \u00221\u0022\u003B\u000D\u000A        int start \u003D 1\u003B\u000D\u000A        while(start \u003C n){\u000D\u000A            StringBuilder res \u003D new StringBuilder()\u003B\u000D\u000A            int count \u003D 1\u003B\u000D\u000A            for(int i\u003D1\u003Bi\u003CcurRes.length()\u003Bi++){\u000D\u000A                if(curRes.charAt(i) \u003D\u003D curRes.charAt(i\u002D1))\u000D\u000A                    count++\u003B\u000D\u000A                else{\u000D\u000A                    res.append(count)\u003B\u000D\u000A                    res.append(curRes.charAt(i\u002D1))\u003B\u000D\u000A                    count \u003D 1\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A            res.append(count)\u003B\u000D\u000A            res.append(curRes.charAt(curRes.length()\u002D1))\u003B\u000D\u000A            curRes \u003D res.toString()\u003B\u000D\u000A            start++\u003B\u000D\u000A        }\u000D\u000A        return curRes\u003B\u000D\u000A    }\u000D\u000A}';
Sudoku Solver =>     scope.code.java = 'public class Solution {\u000D\u000A    public void solveSudoku(char[][] board) {\u000D\u000A        if (board\u003D\u003Dnull||board.length\u003D\u003D0){\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A\u000D\u000A        solved(board)\u003B\u000D\u000A\u000D\u000A\u000D\u000A    }\u000D\u000A    private boolean solved(char[][] board){\u000D\u000A\u000D\u000A        for(int i\u003D0\u003B i\u003Cboard.length\u003B i++){\u000D\u000A            for (int j\u003D0\u003B j\u003Cboard[0].length\u003B j++){\u000D\u000A                if (board[i][j]\u003D\u003D\u0027.\u0027){\u000D\u000A                    for (char num\u003D\u00271\u0027\u003B num\u003C\u003D\u00279\u0027\u003B num++){\u000D\u000A\u000D\u000A                        if(isValid(board, i, j, num)){\u000D\u000A                            // no conflict\u000D\u000A                            board[i][j]\u003Dnum\u003B\u000D\u000A\u000D\u000A                            if (solved(board)){\u000D\u000A                                return true\u003B\u000D\u000A                            }\u000D\u000A                        }\u000D\u000A                        board[i][j] \u003D \u0027.\u0027\u003B\u000D\u000A\u000D\u000A                    }\u000D\u000A                    // if no proper number found, return false\u000D\u000A                    return false\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private boolean isValid(char[][] board, int i, int j, char c){\u000D\u000A\u000D\u000A        // check column\u000D\u000A        for (int row\u003D0\u003B row\u003C9\u003B row++){\u000D\u000A            if (board[row][j]\u003D\u003Dc){\u000D\u000A                return false\u003B\u000D\u000A            }\u000D\u000A\u000D\u000A\u000D\u000A        }\u000D\u000A\u000D\u000A        // check row\u000D\u000A        for (int col\u003D0\u003B col\u003C9\u003B col++){\u000D\u000A            if (board[i][col]\u003D\u003Dc){\u000D\u000A                return false\u003B\u000D\u000A            }\u000D\u000A\u000D\u000A        }\u000D\u000A\u000D\u000A        // check block\u000D\u000A        for(int row\u003Di/3*3\u003B row\u003Ci/3*3+3\u003B row++){\u000D\u000A            for (int col\u003Dj/3*3\u003B col\u003Cj/3*3+3\u003B col++){\u000D\u000A                if (board[row][col]\u003D\u003Dc){\u000D\u000A                    return false\u003B\u000D\u000A                }\u000D\u000A\u000D\u000A            }\u000D\u000A        }\u000D\u000A\u000D\u000A        return true\u003B\u000D\u000A\u000D\u000A    }\u000D\u000A}';
Sudoku Solver =>     scope.code.java = 'public class Solution {\u000D\u000A    public void solveSudoku(char[][] board) {\u000D\u000A        if (board\u003D\u003Dnull||board.length\u003D\u003D0){\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A\u000D\u000A        solved(board)\u003B\u000D\u000A\u000D\u000A\u000D\u000A    }\u000D\u000A    private boolean solved(char[][] board){\u000D\u000A\u000D\u000A        for(int i\u003D0\u003B i\u003Cboard.length\u003B i++){\u000D\u000A            for (int j\u003D0\u003B j\u003Cboard[0].length\u003B j++){\u000D\u000A                if (board[i][j]\u003D\u003D\u0027.\u0027){\u000D\u000A                    for (char num\u003D\u00271\u0027\u003B num\u003C\u003D\u00279\u0027\u003B num++){\u000D\u000A\u000D\u000A                        if(isValid(board, i, j, num)){\u000D\u000A                            // no conflict\u000D\u000A                            board[i][j]\u003Dnum\u003B\u000D\u000A\u000D\u000A                            if (solved(board)){\u000D\u000A                                return true\u003B\u000D\u000A                            }\u000D\u000A                            else{\u000D\u000A                                board[i][j]\u003D\u0027.\u0027\u003B\u000D\u000A                            }\u000D\u000A\u000D\u000A                        }\u000D\u000A\u000D\u000A                    }\u000D\u000A                    // if no proper number found, return false\u000D\u000A                    return false\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private boolean isValid(char[][] board, int i, int j, char c){\u000D\u000A\u000D\u000A        // check column\u000D\u000A        for (int row\u003D0\u003B row\u003C9\u003B row++){\u000D\u000A            if (board[row][j]\u003D\u003Dc){\u000D\u000A                return false\u003B\u000D\u000A            }\u000D\u000A\u000D\u000A\u000D\u000A        }\u000D\u000A\u000D\u000A        // check row\u000D\u000A        for (int col\u003D0\u003B col\u003C9\u003B col++){\u000D\u000A            if (board[i][col]\u003D\u003Dc){\u000D\u000A                return false\u003B\u000D\u000A            }\u000D\u000A\u000D\u000A        }\u000D\u000A\u000D\u000A        // check block\u000D\u000A        for(int row\u003Di/3*3\u003B row\u003Ci/3*3+3\u003B row++){\u000D\u000A            for (int col\u003Dj/3*3\u003B col\u003Cj/3*3+3\u003B col++){\u000D\u000A                if (board[row][col]\u003D\u003Dc){\u000D\u000A                    return false\u003B\u000D\u000A                }\u000D\u000A\u000D\u000A            }\u000D\u000A        }\u000D\u000A\u000D\u000A        return true\u003B\u000D\u000A\u000D\u000A    }\u000D\u000A}';
Valid Sudoku =>     scope.code.java = 'public class Solution {\u000D\u000A       public boolean isValidSudoku(char[][] board){\u000D\u000A        if(board \u003D\u003D null || board.length !\u003D 9)\u000D\u000A            return false\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003C9\u003Bi++){\u000D\u000A            for(int j\u003D0\u003Bj\u003C9\u003Bj++){\u000D\u000A                if(board[i][j] \u003D\u003D \u0027.\u0027)\u000D\u000A                    continue\u003B\u000D\u000A                else{\u000D\u000A                    for (int k \u003D 0\u003B k \u003C 9\u003B k++) {\u000D\u000A                        if (k !\u003D j \u0026\u0026 board[i][j] \u003D\u003D board[i][k])\u000D\u000A                            return false\u003B\u000D\u000A                    }\u000D\u000A                    for (int k \u003D 0\u003B k \u003C 9\u003B k++) {\u000D\u000A                        if (k !\u003D i \u0026\u0026 board[i][j] \u003D\u003D board[k][j])\u000D\u000A                            return false\u003B\u000D\u000A                    }\u000D\u000A                    for (int row \u003D i / 3 * 3\u003B row \u003C i / 3 * 3 + 3\u003B row++) {\u000D\u000A                        for (int col \u003D j / 3 * 3\u003B col \u003C j / 3 * 3 + 3\u003B col++) {\u000D\u000A                            if ((row !\u003D i || col !\u003D j) \u0026\u0026 board[row][col] \u003D\u003D board[i][j])\u000D\u000A                                return false\u003B\u000D\u000A                        }\u000D\u000A                    }\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A}';
Valid Sudoku =>     scope.code.java = 'public class Solution {\u000D\u000A    public boolean isValidSudoku(char[][] board) {\u000D\u000A        List\u003CHashSet\u003CCharacter\u003E\u003E container \u003D new ArrayList\u003CHashSet\u003CCharacter\u003E\u003E()\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003C27\u003Bi++){\u000D\u000A            HashSet\u003CCharacter\u003E tmp \u003D new HashSet\u003CCharacter\u003E()\u003B\u000D\u000A            container.add(tmp)\u003B\u000D\u000A        }\u000D\u000A        for(int i\u003D0\u003B i\u003C9\u003B i++){\u000D\u000A            for(int j\u003D0\u003Bj\u003C9\u003Bj++){\u000D\u000A                char t \u003D board[i][j]\u003B\u000D\u000A                if(t \u003D\u003D \u0027.\u0027)\u000D\u000A                    continue\u003B\u000D\u000A                else{\u000D\u000A                    if(container.get(i).contains(t))\u000D\u000A                        return false\u003B\u000D\u000A                    else\u000D\u000A                        container.get(i).add(t)\u003B\u000D\u000A\u000D\u000A                    if(container.get(9+j).contains(t))\u000D\u000A                        return false\u003B\u000D\u000A                    else\u000D\u000A                        container.get(9+j).add(t)\u003B\u000D\u000A\u000D\u000A                    if(container.get(18+(i/3)*3+j/3).contains(t))\u000D\u000A                        return false\u003B\u000D\u000A                    else\u000D\u000A                        container.get(18+(i/3)*3+j/3).add(t)\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return true\u003B\u000D\u000A    }\u000D\u000A}';
Search Insert Position =>     scope.code.java = 'public class Solution {\u000D\u000A    public int searchInsert(int[] A, int target) {\u000D\u000A        if(A[0] \u003E target)\u000D\u000A            return 0\u003B\u000D\u000A        if(A.length \u003D\u003D 0 || A\u003D\u003Dnull)\u000D\u000A            return 0\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003CA.length\u002D1\u003Bi++) {\u000D\u000A            if (A[i] \u003D\u003D target)\u000D\u000A                return i\u003B\u000D\u000A            if(A[i]\u003Ctarget \u0026\u0026 target\u003CA[i+1])\u000D\u000A                return i+1\u003B\u000D\u000A        }\u000D\u000A        if(A[A.length\u002D1] \u003D\u003D target)\u000D\u000A            return A.length\u002D1\u003B\u000D\u000A        else if(A[A.length\u002D1] \u003E target)\u000D\u000A            return A.length\u002D1\u003B\u000D\u000A        else\u000D\u000A            return A.length\u003B\u000D\u000A    }\u000D\u000A}';
Search for a Range =>     scope.code.java = 'public class Solution {\u000D\u000A    public int[] searchRange(int[] A,int target){\u000D\u000A        int[] res \u003D new int[2]\u003B\u000D\u000A        int low \u003D 0,high \u003D A.length\u002D1\u003B\u000D\u000A        while(low\u003C\u003Dhigh){\u000D\u000A            int mid \u003D (low+high)/2\u003B\u000D\u000A            if(A[mid] \u003D\u003D target){\u000D\u000A                int i\u003Dmid,j\u003Dmid\u003B\u000D\u000A                while(i \u003E\u003D 0 \u0026\u0026 A[i] \u003D\u003D target)\u000D\u000A                    i\u002D\u002D\u003B\u000D\u000A                while(j \u003C A.length \u0026\u0026 A[j] \u003D\u003D target)\u000D\u000A                    j++\u003B\u000D\u000A                res[0] \u003D i+1\u003B\u000D\u000A                res[1] \u003D j\u002D1\u003B\u000D\u000A                return res\u003B\u000D\u000A            }\u000D\u000A            else if(A[mid] \u003C target)\u000D\u000A                low \u003D mid + 1\u003B\u000D\u000A            else\u000D\u000A                high \u003D mid \u002D 1\u003B\u000D\u000A        }\u000D\u000A        res[0] \u003D \u002D1\u003B\u000D\u000A        res[1] \u003D \u002D1\u003B\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Search in Rotated Sorted Array =>     scope.code.java = 'public class Solution {\u000D\u000A    public int search(int[] A,int target){\u000D\u000A        if (A \u003D\u003D null || A.length \u003D\u003D 0)\u000D\u000A            return \u002D1\u003B\u000D\u000A        int low \u003D 0\u003B\u000D\u000A        int high \u003D A.length \u002D 1\u003B\u000D\u000A        while(low \u003C\u003D high){\u000D\u000A            int mid \u003D (low+high)/2\u003B\u000D\u000A            if (A[mid] \u003D\u003D target)\u000D\u000A                return mid\u003B\u000D\u000A            else if (A[mid] \u003E\u003D A[low]){\u000D\u000A                if (A[mid] \u003E target \u0026\u0026 A[low] \u003C\u003D target){\u000D\u000A                    high \u003D mid \u002D 1\u003B\u000D\u000A                }else {\u000D\u000A                    low \u003D mid + 1\u003B\u000D\u000A                }\u000D\u000A            }else {\u000D\u000A                if (A[mid] \u003C target \u0026\u0026 A[high] \u003E\u003D target){\u000D\u000A                    low \u003D mid + 1\u003B\u000D\u000A                }else {\u000D\u000A                    high \u003D mid \u002D 1\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Search in Rotated Sorted Array =>     scope.code.java = 'public class Solution {\u000D\u000A    public int search(int[] A, int target) {\u000D\u000A       int low \u003D 0\u003B\u000D\u000A\u0009\u0009int high \u003D A.length\u002D1\u003B\u000D\u000A\u0009\u0009int mid \u003D (low+high)/2\u003B\u000D\u000A\u0009\u0009while(low \u003C\u003D high){\u000D\u000A\u0009\u0009\u0009if(A[mid] \u003D\u003D target){\u000D\u000A\u0009\u0009\u0009\u0009return mid\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009else if(A[mid] \u003E target){\u000D\u000A\u0009\u0009\u0009\u0009if(A[mid] \u003C A[low]){\u000D\u000A\u0009\u0009\u0009\u0009\u0009high \u003D mid \u002D 1\u003B\u000D\u000A\u0009\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009\u0009if(A[low] \u003D\u003D target){\u000D\u000A\u0009\u0009\u0009\u0009\u0009\u0009return low\u003B\u000D\u000A\u0009\u0009\u0009\u0009\u0009}else if(A[low] \u003E target){\u000D\u000A\u0009\u0009\u0009\u0009\u0009\u0009low \u003D mid + 1\u003B\u000D\u000A\u0009\u0009\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009\u0009\u0009high \u003D mid \u002D1\u003B\u000D\u000A\u0009\u0009\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009else{\u000D\u000A\u0009\u0009\u0009\u0009if(A[mid]\u003CA[low]){\u000D\u000A\u0009\u0009\u0009\u0009\u0009if(A[high] \u003D\u003D target){\u000D\u000A\u0009\u0009\u0009\u0009\u0009\u0009return high\u003B\u000D\u000A\u0009\u0009\u0009\u0009\u0009}else if(A[high] \u003E target){\u000D\u000A\u0009\u0009\u0009\u0009\u0009\u0009low \u003D mid+1\u003B\u000D\u000A\u0009\u0009\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009\u0009\u0009high \u003D mid\u002D1\u003B\u000D\u000A\u0009\u0009\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009\u0009low \u003D mid + 1\u003B\u000D\u000A\u0009\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009mid \u003D (low+high)/2\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Longest Valid Parentheses =>     scope.code.java = 'public class Solution {\u000D\u000A    public int longestValidParentheses(String s) {\u000D\u000A         if (s \u003D\u003D null || s.length() \u003D\u003D 0)\u000D\u000A            return 0\u003B\u000D\u000A        int start \u003D \u002D1\u003B\u000D\u000A        int maxLength \u003D 0\u003B\u000D\u000A        Stack\u003CInteger\u003E stack \u003D new Stack\u003CInteger\u003E()\u003B\u000D\u000A        for (int i\u003D0\u003Bi\u003Cs.length()\u003Bi++){\u000D\u000A            if (s.charAt(i) \u003D\u003D \u0027(\u0027)\u000D\u000A                stack.push(i)\u003B\u000D\u000A            else {\u000D\u000A                if(!stack.empty()){\u000D\u000A                    stack.pop()\u003B\u000D\u000A                    if (stack.isEmpty())\u000D\u000A                        maxLength \u003D Math.max(i\u002Dstart,maxLength)\u003B\u000D\u000A                    else\u000D\u000A                        maxLength \u003D Math.max(i\u002Dstack.peek(),maxLength)\u003B\u000D\u000A                }else\u000D\u000A                    start \u003D i\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return maxLength\u003B\u000D\u000A    }\u000D\u000A}';
Next Permutation =>     scope.code.python = 'class Solution:\u000D\u000A    # @param num, a list of integer\u000D\u000A    # @return a list of integer\u000D\u000A   def nextPermutation(self,num):\u000D\u000A        pivot \u003D \u002D1\u000D\u000A        for i in range(len(num)\u002D1,0,\u002D1):\u000D\u000A            if num[i\u002D1] \u003C num[i]:\u000D\u000A                pivot \u003D i\u002D1\u000D\u000A                break\u000D\u000A        if pivot \u003D\u003D \u002D1:\u000D\u000A            return list(reversed(num))\u000D\u000A        else:\u000D\u000A            minimumval \u003D num[pivot]\u000D\u000A            thres \u003D num[pivot+1]\u000D\u000A            target \u003D pivot+1\u000D\u000A            for idx in range(pivot+1,len(num)):\u000D\u000A                if num[idx] \u003E minimumval and num[idx] \u003C thres:\u000D\u000A                    thres \u003D num[idx]\u000D\u000A                    target \u003D idx\u000D\u000A            num[pivot],num[target] \u003D num[target],num[pivot]\u000D\u000A            return num[:pivot+1] + sorted(num[pivot+1:])\u000D\u000A        ';
Divide Two Integers =>     scope.code.python = 'class Solution:\u000D\u000A    # @return an integer\u000D\u000A  def divide(self,dividend,divisor):\u000D\u000A    flag \u003D True\u000D\u000A    if dividend ^ divisor \u003E\u003D 0:\u000D\u000A      flag \u003D False\u000D\u000A    dividend \u003D abs(dividend)\u000D\u000A    divisor \u003D abs(divisor)\u000D\u000A    if dividend \u003D\u003D divisor:\u000D\u000A      return \u002D1 if flag else 1\u000D\u000A    if divisor \u003D\u003D 1:\u000D\u000A      if flag:\u000D\u000A        return \u002Ddividend\u000D\u000A      else:\u000D\u000A        if dividend \u003E 2147483647:\u000D\u000A          return 2147483647\u000D\u000A        else:\u000D\u000A          return dividend\u000D\u000A    if dividend \u003C divisor:\u000D\u000A      return 0\u000D\u000A    res \u003D 1\u000D\u000A    old \u003D divisor\u000D\u000A    result \u003D []\u000D\u000A    while dividend \u003E old:\u000D\u000A      while dividend\u002Ddivisor \u003E divisor:\u000D\u000A        res +\u003D res\u000D\u000A        divisor +\u003D divisor\u000D\u000A      dividend \u002D\u003D divisor\u000D\u000A      result.append(res)\u000D\u000A      res \u003D 1\u000D\u000A      divisor \u003D old\u000D\u000A    \u000D\u000A    if dividend \u003D\u003D old:\u000D\u000A        result.append(1)\u000D\u000A\u000D\u000A    return \u002Dsum(result) if flag else sum(result)\u000D\u000A\u000D\u000A\u000D\u000A        ';
Implement strStr() =>     scope.code.java = 'public class Solution {\u000D\u000A    public int strStr(String haystack, String needle){\u000D\u000A        if(needle.equals(\u0022\u0022))\u000D\u000A            return 0\u003B\u000D\u000A        int hLen \u003D haystack.length()\u003B\u000D\u000A        int nLen \u003D needle.length()\u003B\u000D\u000A        if(hLen \u003C nLen)\u000D\u000A            return \u002D1\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003ChLen\u002DnLen+1\u003Bi++){\u000D\u000A            int tmp \u003D i\u003B\u000D\u000A            for(int j \u003D i\u003Bj\u003Ci+nLen\u003Bj++){\u000D\u000A                char p \u003D haystack.charAt(tmp)\u003B\u000D\u000A                if(p !\u003D needle.charAt(j\u002Di))\u000D\u000A                    break\u003B\u000D\u000A                else{\u000D\u000A                    if(j\u003D\u003Di+nLen\u002D1)\u000D\u000A                        return i\u003B\u000D\u000A                    tmp++\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return \u002D1\u003B\u000D\u000A    }\u000D\u000A}';
Remove Element =>     scope.code.cpp = 'class Solution {\u000D\u000Apublic:\u000D\u000A    int removeElement(int A[], int n, int elem) {\u000D\u000A        int num \u003D 0\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cn\u003Bi++){\u000D\u000A            if(A[i] !\u003D elem)\u000D\u000A                A[num++] \u003D A[i]\u003B\u000D\u000A        }\u000D\u000A        return num\u003B\u000D\u000A    }\u000D\u000A}\u003B';
Remove Element =>     scope.code.java = 'public class Solution {\u000D\u000A    public int removeElement(int[] A, int elem) {\u000D\u000A        int num\u003D0\u003B\u000D\u000A\u0009\u0009for(int i\u003D0\u003Bi\u003CA.length\u003Bi++){\u000D\u000A\u0009\u0009\u0009if(A[i] !\u003D elem)\u000D\u000A\u0009\u0009\u0009\u0009A[num++] \u003D A[i]\u003B \u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return num\u003B\u000D\u000A        \u000D\u000A    }\u000D\u000A}';
Remove Duplicates from Sorted Array =>     scope.code.java = 'public class Solution {\u000D\u000A    public int removeDuplicates(int[] A) {\u000D\u000A        if (A.length \u003C 2)\u000D\u000A\u0009\u0009\u0009return A.length\u003B\u000D\u000A\u000D\u000A\u0009\u0009int i \u003D 0, j \u003D 1\u003B\u000D\u000A\u0009\u0009while (j \u003C A.length) {\u000D\u000A\u0009\u0009\u0009if (A[j] \u003D\u003D A[i]) {\u000D\u000A\u0009\u0009\u0009\u0009j++\u003B\u000D\u000A\u0009\u0009\u0009} else {\u000D\u000A\u0009\u0009\u0009\u0009A[++i] \u003D A[j]\u003B\u000D\u000A\u0009\u0009\u0009\u0009j++\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009return i+1\u003B\u000D\u000A    }\u000D\u000A}';
Swap Nodes in Pairs =>     scope.code.python = 'class Solution:\u000D\u000A    def swapPairs(self,head):\u000D\u000A        if head is None:\u000D\u000A            return None\u000D\u000A        flag \u003D ListNode(3.14)\u000D\u000A        flag.next \u003D head\u000D\u000A        pre \u003D flag\u000D\u000A        p \u003D head\u000D\u000A        q \u003D p.next\u000D\u000A        while p !\u003D None and q !\u003D None:\u000D\u000A            pre.next \u003D q\u000D\u000A            p.next \u003D q.next\u000D\u000A            q.next \u003D p\u000D\u000A            pre \u003D p\u000D\u000A            p \u003D p.next\u000D\u000A            if p !\u003D None:\u000D\u000A                q \u003D p.next\u000D\u000A        return flag.next';
Generate Parentheses =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CString\u003E generateParenthesis(int n){\u000D\u000A        ArrayList\u003CString\u003E result \u003D new ArrayList\u003CString\u003E()\u003B\u000D\u000A        generate(0,0,\u0022\u0022,n,result)\u003B\u000D\u000A        return result\u003B\u000D\u000A    }\u000D\u000A\u000D\u000A    private void generate(int left,int right,String s,int n,ArrayList\u003CString\u003E res){\u000D\u000A        if (left \u003C right){\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        if(left \u003D\u003D n \u0026\u0026 right \u003D\u003D n){\u000D\u000A            res.add(s)\u003B\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        if(left \u003D\u003D n){\u000D\u000A            generate(left,right+1,s+\u0022)\u0022,n,res)\u003B\u000D\u000A            return\u003B\u000D\u000A        }\u000D\u000A        generate(left+1,right,s+\u0022(\u0022,n,res)\u003B\u000D\u000A        generate(left,right+1,s+\u0022)\u0022,n,res)\u003B\u000D\u000A    }\u000D\u000A}';
Merge Two Sorted Lists =>     scope.code.cpp = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * struct ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode *next\u003B\u000D\u000A *     ListNode(int x) : val(x), next(NULL) {}\u000D\u000A * }\u003B\u000D\u000A */\u000D\u000Aclass Solution {\u000D\u000Apublic:\u000D\u000A   ListNode *mergeTwoLists(ListNode *l1, ListNode *l2){\u000D\u000A    ListNode head(1)\u003B\u000D\u000A    ListNode* p \u003D \u0026head\u003B\u000D\u000A    while(l1 !\u003D NULL \u0026\u0026 l2 !\u003D NULL){\u000D\u000A      if(l1\u002D\u003Eval \u003C\u003D l2\u002D\u003Eval){\u000D\u000A        p\u002D\u003Enext \u003D l1\u003B\u000D\u000A        l1 \u003D l1\u002D\u003Enext\u003B\u000D\u000A      }else{\u000D\u000A        p\u002D\u003Enext \u003D l2\u003B\u000D\u000A        l2 \u003D l2\u002D\u003Enext\u003B\u000D\u000A      }\u000D\u000A      p \u003D p\u002D\u003Enext\u003B\u000D\u000A    }\u000D\u000A    while(l1 !\u003D NULL){\u000D\u000A      p\u002D\u003Enext \u003D l1\u003B\u000D\u000A      p \u003D p\u002D\u003Enext\u003B\u000D\u000A      l1 \u003D l1\u002D\u003Enext\u003B\u000D\u000A    }\u000D\u000A    while(l2 !\u003D NULL){\u000D\u000A      p\u002D\u003Enext \u003D l2\u003B\u000D\u000A      l2 \u003D l2\u002D\u003Enext\u003B\u000D\u000A      p \u003D p\u002D\u003Enext\u003B\u000D\u000A    }\u000D\u000A    return head.next\u003B\u000D\u000A  }\u000D\u000A}\u003B';
Merge Two Sorted Lists =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A   public ListNode mergeTwoLists(ListNode l1, ListNode l2){\u000D\u000A        ListNode p \u003D l1,q \u003D l2\u003B\u000D\u000A        ListNode fakeHead \u003D new ListNode(0)\u003B\u000D\u000A        ListNode f \u003D fakeHead\u003B\u000D\u000A        while(p !\u003D null \u0026\u0026 q !\u003D null){\u000D\u000A            if(p.val \u003C\u003D q.val ){\u000D\u000A                f.next \u003D p\u003B\u000D\u000A                p \u003D p.next\u003B\u000D\u000A            }else{\u000D\u000A                f.next \u003D q\u003B\u000D\u000A                q \u003D q.next\u003B\u000D\u000A            }\u000D\u000A            f \u003D f.next\u003B\u000D\u000A        }\u000D\u000A        if(p !\u003D null)\u000D\u000A            f.next \u003D p\u003B\u000D\u000A        if(q !\u003D null)\u000D\u000A            f.next \u003D q\u003B\u000D\u000A        return fakeHead.next\u003B\u000D\u000A    }\u000D\u000A}';
Valid Parentheses =>     scope.code.java = 'public class Solution {\u000D\u000A    public boolean isValid(String s) {\u000D\u000A        Map\u003CCharacter,Character\u003E table \u003D new HashMap\u003CCharacter,Character\u003E()\u003B\u000D\u000A\u0009\u0009table.put(\u0027]\u0027, \u0027[\u0027)\u003B\u000D\u000A\u0009\u0009table.put(\u0027}\u0027, \u0027{\u0027)\u003B\u000D\u000A\u0009\u0009table.put(\u0027)\u0027, \u0027(\u0027)\u003B\u000D\u000A\u0009\u0009Stack\u003CCharacter\u003E stack \u003D new Stack\u003CCharacter\u003E()\u003B\u000D\u000A\u0009\u0009for(char c : s.toCharArray()){\u000D\u000A\u0009\u0009\u0009switch(c){\u000D\u000A\u0009\u0009\u0009case \u0027(\u0027:\u000D\u000A\u0009\u0009\u0009case \u0027{\u0027:\u000D\u000A\u0009\u0009\u0009case \u0027[\u0027:\u000D\u000A\u0009\u0009\u0009\u0009stack.push(c)\u003B\u000D\u000A\u0009\u0009\u0009\u0009break\u003B\u000D\u000A\u0009\u0009\u0009case \u0027]\u0027:\u000D\u000A\u0009\u0009\u0009case \u0027)\u0027:\u000D\u000A\u0009\u0009\u0009case \u0027}\u0027:\u000D\u000A\u0009\u0009\u0009\u0009if(stack.isEmpty())\u000D\u000A\u0009\u0009\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009\u0009\u0009char top \u003D stack.pop()\u003B\u000D\u000A\u0009\u0009\u0009\u0009if(top !\u003D table.get(c))\u000D\u000A\u0009\u0009\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009if(stack.isEmpty()){\u000D\u000A\u0009\u0009\u0009return true\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return false\u003B\u000D\u000A    }\u000D\u000A}';
Remove Nth Node From End of List =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode removeNthFromEnd(ListNode head, int n){\u000D\u000A\u0009\u0009ListNode p \u003D head\u003B\u000D\u000A\u0009\u0009ListNode q \u003D head\u003B\u000D\u000A\u0009\u0009ListNode pre \u003D null\u003B\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009if(head \u003D\u003D null){\u000D\u000A\u0009\u0009\u0009return null\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009\u000D\u000A\u0009\u0009for(int i\u003D1\u003Bi\u003C\u003Dn\u002D1\u003Bi++){\u000D\u000A\u0009\u0009\u0009q \u003Dq.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(q.next !\u003D null){\u000D\u000A\u0009\u0009\u0009pre \u003D p\u003B\u000D\u000A\u0009\u0009\u0009p \u003D p.next\u003B\u000D\u000A\u0009\u0009\u0009q \u003D q.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009if(pre \u003D\u003D null ){\u000D\u000A\u0009\u0009\u0009head \u003D p.next\u003B\u000D\u000A\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009pre.next \u003D p.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return head\u003B\u000D\u000A\u0009}\u000D\u000A    \u000D\u000A}';
4Sum =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E fourSum(int[] num, int target){\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(num.length\u003C4)\u000D\u000A            return res\u003B\u000D\u000A        Arrays.sort(num)\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cnum.length\u002D3\u003Bi++){\u000D\u000A            if(num[i] \u003E target/4)\u000D\u000A                break\u003B\u000D\u000A            if(i\u003D\u003D0 || num[i] \u003E num[i\u002D1]){\u000D\u000A                ArrayList\u003CArrayList\u003CInteger\u003E\u003E tmp \u003D threeSum(num,target\u002Dnum[i],i+1,num.length\u002D1)\u003B\u000D\u000A                if(tmp !\u003D null)\u000D\u000A                    res.addAll(tmp)\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A    \u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E threeSum(int[] num,int target,int low,int high) {\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(num.length \u003C 3)\u000D\u000A            return res\u003B\u000D\u000A        for(int i\u003Dlow\u003Bi\u003Chigh\u002D1\u003Bi++){\u000D\u000A            if(num[i] \u003E target/3)\u000D\u000A                break\u003B\u000D\u000A            if(i \u003D\u003D low || num[i] \u003E num[i\u002D1]){\u000D\u000A                int remain \u003D target\u002Dnum[i]\u003B\u000D\u000A                int start \u003D i + 1\u003B\u000D\u000A                int end \u003D num.length\u002D1\u003B\u000D\u000A                while(start\u003Cend){\u000D\u000A                    if(num[start] + num[end] \u003D\u003D remain){\u000D\u000A                        ArrayList\u003CInteger\u003E tmp \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A                        tmp.add(num[low\u002D1])\u003B\u000D\u000A                        tmp.add(num[i])\u003B\u000D\u000A                        tmp.add(num[start])\u003B\u000D\u000A                        tmp.add(num[end])\u003B\u000D\u000A                        res.add(tmp)\u003B\u000D\u000A                        start++\u003B\u000D\u000A                        end\u002D\u002D\u003B\u000D\u000A                        while (start\u003Cend \u0026\u0026 num[start] \u003D\u003D num[start\u002D1])\u000D\u000A                            start++\u003B\u000D\u000A                        while(start\u003Cend \u0026\u0026 num[end] \u003D\u003D num[end+1])\u000D\u000A                            end\u002D\u002D\u003B\u000D\u000A                    }else if(num[start] + num[end] \u003C remain){\u000D\u000A                        start++\u003B\u000D\u000A                    }else\u000D\u000A                        end\u002D\u002D\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
Letter Combinations of a Phone Number =>     scope.code.python = 'class Solution:\u000D\u000A\u0009def __init__(self):\u000D\u000A\u0009\u0009self.button \u003D {\u00272\u0027: \u0022abc\u0022,\u00273\u0027: \u0022def\u0022,\u00274\u0027: \u0022ghi\u0022,\u00275\u0027: \u0022jkl\u0022,\u000D\u000A\u0009\u0009\u00276\u0027: \u0022mno\u0022,\u00277\u0027: \u0022pqrs\u0022,\u00278\u0027: \u0022tuv\u0022,\u00279\u0027: \u0022wxyz\u0022}\u000D\u000A\u0009def letterCombinations(self,digits):\u000D\u000A\u0009\u0009res \u003D []\u000D\u000A\u0009\u0009if digits \u003D\u003D \u0022\u0022:\u000D\u000A\u0009\u0009\u0009return res\u000D\u000A\u0009\u0009item \u003D []\u000D\u000A\u0009\u0009size \u003D len(digits)\u000D\u000A\u0009\u0009self.helper(digits,0,size,item,res)\u000D\u000A\u0009\u0009return res\u000D\u000A\u0009def helper(self,digits,n,size,item,res):\u000D\u000A\u0009\u0009if n \u003D\u003D size:\u000D\u000A\u0009\u0009\u0009res.append(\u0022\u0022.join(item))\u000D\u000A\u0009\u0009\u0009return\u000D\u000A\u0009\u0009for i in range(len(self.button[digits[n]])):\u000D\u000A\u0009\u0009\u0009item.append(self.button[digits[n]][i])\u000D\u000A\u0009\u0009\u0009self.helper(digits,n+1,size,item,res)\u000D\u000A\u0009\u0009\u0009del item[\u002D1]';
3Sum Closest =>     scope.code.java = 'public class Solution {\u000D\u000A    public int threeSumClosest(int[] num,int target){\u000D\u000A        Arrays.sort(num)\u003B\u000D\u000A        int result \u003D num[0]+num[1]+num[2]\u003B\u000D\u000A        int min \u003D Math.abs(target\u002Dresult)\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cnum.length\u002D2\u003Bi++){\u000D\u000A            if(num[i] \u003E target/3)\u000D\u000A                break\u003B\u000D\u000A            if(i \u003D\u003D 0 || num[i] \u003E num[i\u002D1]){\u000D\u000A                int start \u003D i + 1\u003B\u000D\u000A                int end \u003D num.length\u002D1\u003B\u000D\u000A                while(start\u003Cend){\u000D\u000A                    int sum \u003D num[i] + num[start]+num[end]\u003B\u000D\u000A                    int diff \u003D Math.abs(sum\u002Dtarget)\u003B\u000D\u000A                    if(diff \u003D\u003D 0){\u000D\u000A                        return target\u003B\u000D\u000A                    }\u000D\u000A                    if(diff \u003C min){\u000D\u000A                        min \u003D diff\u003B\u000D\u000A                        result \u003D sum\u003B\u000D\u000A                    }\u000D\u000A                    if(sum \u003C target)\u000D\u000A                        start++\u003B\u000D\u000A                    else\u000D\u000A                        end\u002D\u002D\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return result\u003B\u000D\u000A    }\u000D\u000A}';
3Sum =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E threeSum(int[] num) {\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E res \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        if(num.length \u003C 3)\u000D\u000A            return res\u003B\u000D\u000A        Arrays.sort(num)\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cnum.length\u002D2\u003Bi++){\u000D\u000A            if(num[i] \u003E 0)\u000D\u000A                break\u003B\u000D\u000A            if(i \u003D\u003D 0 || num[i] \u003E num[i\u002D1]){\u000D\u000A                int negate \u003D \u002Dnum[i]\u003B\u000D\u000A                int start \u003D i + 1\u003B\u000D\u000A                int end \u003D num.length\u002D1\u003B\u000D\u000A                while(start\u003Cend){\u000D\u000A                    if(num[start] + num[end] \u003D\u003D negate){\u000D\u000A                        ArrayList\u003CInteger\u003E tmp \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A                        tmp.add(num[i])\u003B\u000D\u000A                        tmp.add(num[start])\u003B\u000D\u000A                        tmp.add(num[end])\u003B\u000D\u000A                        res.add(tmp)\u003B\u000D\u000A                        start++\u003B\u000D\u000A                        end\u002D\u002D\u003B\u000D\u000A                        while (start\u003Cend \u0026\u0026 num[start] \u003D\u003D num[start\u002D1])\u000D\u000A                            start++\u003B\u000D\u000A                        while(start\u003Cend \u0026\u0026 num[end] \u003D\u003D num[end+1])\u000D\u000A                            end\u002D\u002D\u003B\u000D\u000A                    }else if(num[start] + num[end] \u003C negate){\u000D\u000A                        start++\u003B\u000D\u000A                    }else\u000D\u000A                        end\u002D\u002D\u003B\u000D\u000A                }\u000D\u000A            }\u000D\u000A        }\u000D\u000A        return res\u003B\u000D\u000A    }\u000D\u000A}';
3Sum =>     scope.code.java = 'public class Solution {\u000D\u000A    public ArrayList\u003CArrayList\u003CInteger\u003E\u003E threeSum(int[] num){\u000D\u000A        ArrayList\u003CArrayList\u003CInteger\u003E\u003E result \u003D new ArrayList\u003CArrayList\u003CInteger\u003E\u003E()\u003B\u000D\u000A        List\u003CInteger\u003E myList \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A        HashMap\u003CInteger,Integer\u003E tmp \u003D new HashMap\u003CInteger, Integer\u003E()\u003B\u000D\u000A        for(int i : num){\u000D\u000A            if (tmp.containsKey(i)) {\u000D\u000A                tmp.put(i, tmp.get(i) + 1)\u003B\u000D\u000A                if(tmp.get(i) \u003C\u003D 2)\u000D\u000A                    myList.add(i)\u003B\u000D\u000A            }\u000D\u000A            else {\u000D\u000A                tmp.put(i, 1)\u003B\u000D\u000A                myList.add(i)\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A        int[] myNum \u003D new int[myList.size()]\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003CmyNum.length\u003Bi++)\u000D\u000A            myNum[i] \u003D myList.get(i)\u003B\u000D\u000A        Arrays.sort(myNum)\u003B\u000D\u000A        if(tmp.containsKey(0) \u0026\u0026 tmp.get(0) \u003E\u003D 3){\u000D\u000A            ArrayList\u003CInteger\u003E fin \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A            fin.add(0)\u003B\u000D\u000A            fin.add(0)\u003B\u000D\u000A            fin.add(0)\u003B\u000D\u000A            result.add(fin)\u003B\u000D\u000A        }\u000D\u000A\u000D\u000A        for(int i\u003D0\u003Bi\u003CmyNum.length\u002D2\u003Bi++){\u000D\u000A            if(i\u003E0 \u0026\u0026 myNum[i\u002D1] \u003D\u003D myNum[i])\u000D\u000A                continue\u003B\u000D\u000A            for(int j\u003Di+1\u003Bj\u003CmyNum.length\u002D1\u003Bj++){\u000D\u000A                if(myNum[j\u002D1] \u003D\u003D myNum[j] \u0026\u0026 j\u002D1 !\u003D i)\u000D\u000A                    continue\u003B\u000D\u000A                int res \u003D 0 \u002D myNum[i] \u002D myNum[j]\u003B\u000D\u000A                if(res \u003C myNum[j])\u000D\u000A                    break\u003B\u000D\u000A                else if(res \u003D\u003D myNum[j]){\u000D\u000A                    if(res !\u003D 0 \u0026\u0026 tmp.get(res) \u003E\u003D 2){\u000D\u000A                        ArrayList\u003CInteger\u003E fin \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A                        fin.add(myNum[i])\u003B\u000D\u000A                        fin.add(myNum[j])\u003B\u000D\u000A                        fin.add(res)\u003B\u000D\u000A                        result.add(fin)\u003B\u000D\u000A                        tmp.put(res,1)\u003B\u000D\u000A                    }\u000D\u000A                }\u000D\u000A                else{\u000D\u000A                    if(tmp.containsKey(res)){\u000D\u000A                        ArrayList\u003CInteger\u003E fin \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A                        fin.add(myNum[i])\u003B\u000D\u000A                        fin.add(myNum[j])\u003B\u000D\u000A                        fin.add(res)\u003B\u000D\u000A                        result.add(fin)\u003B\u000D\u000A                    }\u000D\u000A                }\u000D\u000A            }\u000D\u000A            \u000D\u000A        }\u000D\u000A        return result\u003B\u000D\u000A    }\u000D\u000A}';
Longest Common Prefix =>     scope.code.java = 'public class Solution {\u000D\u000A    public String longestCommonPrefix(String[] strs) {\u000D\u000A        if(strs.length \u003D\u003D 0)\u000D\u000A\u0009\u0009\u0009return \u0022\u0022\u003B\u000D\u000A        int min \u003D Integer.MAX_VALUE\u003B\u000D\u000A\u0009\u0009String min_str \u003D \u0022\u0022\u003B\u000D\u000A\u0009\u0009for(String str : strs)\u000D\u000A\u0009\u0009\u0009if(min \u003E str.length()){\u000D\u000A\u0009\u0009\u0009\u0009min \u003D str.length()\u003B\u000D\u000A\u0009\u0009\u0009\u0009min_str \u003D str\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009boolean flag \u003D true\u003B\u000D\u000A\u0009\u0009for(int i\u003Dmin\u003B i\u003E\u003D0\u003B i\u002D\u002D){\u000D\u000A\u0009\u0009\u0009for(int j\u003D0\u003B j\u003Cstrs.length\u003B j++){\u000D\u000A\u0009\u0009\u0009\u0009if(!strs[j].substring(0,i).equals(min_str.substring(0,i))){\u000D\u000A\u0009\u0009\u0009\u0009\u0009flag \u003D false\u003B\u000D\u000A\u0009\u0009\u0009\u0009\u0009break\u003B\u000D\u000A\u0009\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009\u0009flag \u003D true\u003B\u000D\u000A\u0009\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009if(flag) return min_str.substring(0,i)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return \u0022\u0022\u003B\u000D\u000A    }\u000D\u000A}';
Roman to Integer =>     scope.code.java = 'public class Solution {\u000D\u000A    public static int charToInt(char c) {\u000D\u000A        int data \u003D 0\u003B\u000D\u000A\u000D\u000A        switch (c) {\u000D\u000A            case \u0027I\u0027:\u000D\u000A                data \u003D 1\u003B\u000D\u000A                break\u003B\u000D\u000A            case \u0027V\u0027:\u000D\u000A                data \u003D 5\u003B\u000D\u000A                break\u003B\u000D\u000A            case \u0027X\u0027:\u000D\u000A                data \u003D 10\u003B\u000D\u000A                break\u003B\u000D\u000A            case \u0027L\u0027:\u000D\u000A                data \u003D 50\u003B\u000D\u000A                break\u003B\u000D\u000A            case \u0027C\u0027:\u000D\u000A                data \u003D 100\u003B\u000D\u000A                break\u003B\u000D\u000A            case \u0027D\u0027:\u000D\u000A                data \u003D 500\u003B\u000D\u000A                break\u003B\u000D\u000A            case \u0027M\u0027:\u000D\u000A                data \u003D 1000\u003B\u000D\u000A                break\u003B\u000D\u000A        }\u000D\u000A        return  data\u003B\u000D\u000A    }\u000D\u000A    public static int romanToInt(String s) {\u000D\u000A        int i, total, pre, cur\u003B\u000D\u000A\u000D\u000A        total \u003D charToInt(s.charAt(0))\u003B\u000D\u000A\u000D\u000A        for (i \u003D 1\u003B i \u003C s.length()\u003B i++) {\u000D\u000A            pre \u003D charToInt(s.charAt(i \u002D 1))\u003B\u000D\u000A            cur \u003D charToInt(s.charAt(i))\u003B\u000D\u000A\u000D\u000A            if (cur \u003C\u003D pre) {\u000D\u000A                total +\u003D cur\u003B\u000D\u000A            } else {\u000D\u000A                total \u003D total \u002D pre * 2 + cur\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A\u000D\u000A        return total\u003B\u000D\u000A    }\u000D\u000A}';
Integer to Roman =>     scope.code.java = 'public class Solution {\u000D\u000A    public String intToRoman(int num) {\u000D\u000A        String str \u003D \u0022\u0022\u003B    \u000D\u000A        String symbol[]\u003D{\u0022M\u0022,\u0022CM\u0022,\u0022D\u0022,\u0022CD\u0022,\u0022C\u0022,\u0022XC\u0022,\u0022L\u0022,\u0022XL\u0022,\u0022X\u0022,\u0022IX\u0022,\u0022V\u0022,\u0022IV\u0022,\u0022I\u0022}\u003B    \u000D\u000A        int value[]\u003D    {1000,900,500,400, 100, 90,  50, 40,  10, 9,   5,  4,   1}\u003B   \u000D\u000A        for(int i\u003D0\u003Bnum!\u003D0\u003B++i)  \u000D\u000A        {  \u000D\u000A            while(num\u003E\u003Dvalue[i])  \u000D\u000A            {  \u000D\u000A                num\u002D\u003Dvalue[i]\u003B  \u000D\u000A                str+\u003Dsymbol[i]\u003B  \u000D\u000A            }  \u000D\u000A        }  \u000D\u000A        return str\u003B  \u000D\u000A    }  \u000D\u000A}';
Container With Most Water =>     scope.code.python = 'class Solution:\u000D\u000A    # @return an integer\u000D\u000A   def maxArea(self,height):\u000D\u000A        start \u003D 0\u003Bend \u003D len(height)\u002D1\u000D\u000A        res \u003D 0\u000D\u000A        while start \u003C end:\u000D\u000A            res \u003D max(res,(end\u002Dstart) * min(height[start],height[end]))\u000D\u000A            if height[start] \u003C height[end]:\u000D\u000A                start +\u003D 1\u000D\u000A            else:\u000D\u000A                end \u002D\u003D 1\u000D\u000A        return res\u000D\u000A        ';
Palindrome Number =>     scope.code.java = 'public class Solution {\u000D\u000A    public boolean isPalindrome(int x) {\u000D\u000A       if(x\u003C0)\u000D\u000A\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009if(x\u003E\u003D0 \u0026\u0026 x\u003C10)\u000D\u000A\u0009\u0009\u0009return true\u003B\u000D\u000A\u0009\u0009int div \u003D 1\u003B\u000D\u000A\u0009\u0009while(x / div \u003E\u003D 10){\u000D\u000A\u0009\u0009\u0009div *\u003D 10\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(x !\u003D 0){\u000D\u000A\u0009\u0009\u0009int first \u003D x/div\u003B\u000D\u000A\u0009\u0009\u0009int last \u003D x%10\u003B\u000D\u000A\u0009\u0009\u0009if(first !\u003D last)\u000D\u000A\u0009\u0009\u0009\u0009return false\u003B\u000D\u000A\u0009\u0009\u0009x \u003D (x%div) / 10\u003B\u000D\u000A\u0009\u0009\u0009div /\u003D 100\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return true\u003B\u000D\u000A    }\u000D\u000A}';
String to Integer (atoi) =>     scope.code.java = 'public class Solution {\u000D\u000A    public int myAtoi(String str) {\u000D\u000A        int digit \u003D 0\u003B\u000D\u000A        double number \u003D 0\u003B\u000D\u000A        str \u003D str.trim()\u003B\u000D\u000A         \u000D\u000A        boolean signed \u003D false\u003B\u000D\u000A         \u000D\u000A        for (int i\u003Dstr.length()\u002D1\u003B i\u003E\u003D0\u003B i\u002D\u002D) {\u000D\u000A            char ch \u003D str.charAt(i)\u003B\u000D\u000A            if (ch\u003E\u003D\u00270\u0027 \u0026\u0026 ch\u003C\u003D\u00279\u0027) { // number\u000D\u000A                number +\u003D (ch\u002D\u00270\u0027) * (int)Math.pow(10, digit)\u003B\u000D\u000A                digit++\u003B\u000D\u000A            } else if(ch\u003D\u003D\u0027\u002D\u0027 || ch\u003D\u003D\u0027+\u0027) {\u000D\u000A                if(signed)\u000D\u000A                    return 0\u003B\u000D\u000A                signed \u003D true\u003B\u000D\u000A                 \u000D\u000A                if (ch\u003D\u003D\u0027\u002D\u0027)\u000D\u000A                    number \u003D \u002Dnumber\u003B\u000D\u000A            } else {\u000D\u000A                number \u003D 0\u003B\u000D\u000A                digit \u003D 0\u003B\u000D\u000A                 \u000D\u000A                signed \u003D false\u003B\u000D\u000A            }\u000D\u000A        }\u000D\u000A         \u000D\u000A        if (number\u003EInteger.MAX_VALUE)\u000D\u000A            return Integer.MAX_VALUE\u003B\u000D\u000A        if (number\u003C\u003DInteger.MIN_VALUE)\u000D\u000A            return Integer.MIN_VALUE\u003B\u000D\u000A         \u000D\u000A        return (int)number\u003B\u000D\u000A    }\u000D\u000A}';
Reverse Integer =>     scope.code.java = 'public class Solution {\u000D\u000A    public int reverse(int x){\u000D\u000A\u0009    int res \u003D 0\u003B\u000D\u000A\u0009\u0009while(x !\u003D 0){\u000D\u000A\u0009\u0009\u0009if(res \u003E (Integer.MAX_VALUE/10) || res \u003C (Integer.MIN_VALUE/10))\u000D\u000A\u0009\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009\u0009res \u003D res * 10 + x % 10 \u003B\u000D\u000A\u0009\u0009\u0009x \u003D x/10\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return res\u003B\u000D\u000A\u0009}\u000D\u000A}';
Reverse Integer =>     scope.code.java = 'public class Solution {\u000D\u000A    public int reverse(int x) {\u000D\u000A        int res \u003D 0\u003B\u000D\u000A\u0009\u0009List\u003CInteger\u003E result_list \u003D new ArrayList\u003CInteger\u003E()\u003B\u000D\u000A\u0009\u0009//设置标志flag，x是否为负数\u000D\u000A\u0009\u0009boolean flag \u003D false\u003B\u000D\u000A\u0009\u0009if(x \u003C 0){\u000D\u000A\u0009\u0009\u0009flag \u003D true\u003B\u000D\u000A\u0009\u0009\u0009x \u003D Math.abs(x)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009//当x为个位数\u000D\u000A\u0009\u0009if(0 \u003C\u003D x \u0026\u0026 x\u003C10){\u000D\u000A\u0009\u0009\u0009if(flag){\u000D\u000A\u0009\u0009\u0009\u0009return \u002Dx\u003B\u000D\u000A\u0009\u0009\u0009} else{\u000D\u000A\u0009\u0009\u0009\u0009return x\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(x \u003E\u003D 10){\u000D\u000A\u0009\u0009\u0009int mod \u003D x % 10\u003B\u000D\u000A\u0009\u0009\u0009x \u003D x/10\u003B\u000D\u000A\u0009\u0009\u0009result_list.add(mod)\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009result_list.add(x)\u003B\u000D\u000A\u0009\u0009for(int i\u003D0\u003B i\u003Cresult_list.size()\u003B i++){\u000D\u000A\u0009\u0009    if(flag){\u000D\u000A\u0009\u0009\u0009\u0009res +\u003D (\u002Dresult_list.get(i))*(Math.pow(10, result_list.size()\u002D1\u002Di))\u003B\u000D\u000A\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009res +\u003D result_list.get(i)*(Math.pow(10, result_list.size()\u002D1\u002Di))\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009if(res \u003D\u003D Integer.MIN_VALUE)\u000D\u000A\u0009\u0009    return 0\u003B\u000D\u000A\u0009\u0009else if(res \u003D\u003D Integer.MAX_VALUE)\u000D\u000A\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009else\u000D\u000A\u0009\u0009\u0009return res\u003B\u000D\u000A    }\u000D\u000A}';
ZigZag Conversion =>     scope.code.python = 'class Solution:\u000D\u000A    # @return a string\u000D\u000A    def convert(self,s,nRows):\u000D\u000A        if nRows \u003D\u003D 1:\u000D\u000A            return s\u000D\u000A        res \u003D []\u000D\u000A        for idx in range(1,nRows+1):\u000D\u000A            target \u003D idx\u002D1\u000D\u000A            while target\u003Clen(s):\u000D\u000A                if idx \u003D\u003D 1 or idx \u003D\u003D nRows:\u000D\u000A                    res.append(s[target])\u000D\u000A                    target +\u003D (2*nRows\u002D2)\u000D\u000A                else:\u000D\u000A                    res.append(s[target])\u000D\u000A                    if target+2*nRows\u002D2*idx \u003C len(s):\u000D\u000A                        res.append(s[target+2*nRows\u002D2*idx])\u000D\u000A                    target +\u003D (2*nRows\u002D2)\u000D\u000A        return \u0022\u0022.join(res)\u000D\u000A        ';
Longest Palindromic Substring =>     scope.code.java = 'public class Solution {\u000D\u000A    public String longestPalindrome(String s) {\u000D\u000A        int n \u003D s.length()\u003B\u000D\u000A        if(n \u003C\u003D 1)\u000D\u000A            return s\u003B\u000D\u000A        String longest \u003D s.substring(0,1)\u003B\u000D\u000A        for(int i\u003D0\u003Bi\u003Cn\u003Bi++){\u000D\u000A            String p1 \u003D expandAroundCenter(s,i,i)\u003B\u000D\u000A            if(p1.length()\u003Elongest.length()){\u000D\u000A                longest \u003D p1\u003B\u000D\u000A            }\u000D\u000A\u000D\u000A            String p2 \u003D expandAroundCenter(s,i,i+1)\u003B\u000D\u000A            if(p2.length()\u003Elongest.length())\u000D\u000A                longest \u003D p2\u003B\u000D\u000A        }\u000D\u000A        return longest\u003B\u000D\u000A    }\u000D\u000A    \u000D\u000A    private String expandAroundCenter(String s, int c1, int c2){\u000D\u000A        int l \u003D c1,r \u003D c2\u003B\u000D\u000A        int n \u003D s.length()\u003B\u000D\u000A        while(l\u003E\u003D0 \u0026\u0026 r\u003C\u003Dn\u002D1 \u0026\u0026 s.charAt(l) \u003D\u003D s.charAt(r)){\u000D\u000A            l\u002D\u002D\u003B\u000D\u000A            r++\u003B\u000D\u000A        }\u000D\u000A        return s.substring(l+1,r)\u003B\u000D\u000A    }\u000D\u000A}';
Median of Two Sorted Arrays =>     scope.code.python = 'class Solution:\u000D\u000A    # @return a float\u000D\u000A    def findMedianSortedArrays(self,A,B):\u000D\u000A        total \u003D len(A) + len(B)\u000D\u000A        if total % 2 \u003D\u003D 0:\u000D\u000A            return (self.findKth(A,len(A),B,len(B),total/2)+self.findKth(A,len(A),B,len(B),total/2+1)) / 2.0\u000D\u000A        else:\u000D\u000A            return self.findKth(A,len(A),B,len(B),total/2+1)\u000D\u000A\u000D\u000A    def findKth(self,A,m,B,n,k):\u000D\u000A        if m \u003E n:\u000D\u000A            return self.findKth(B,n,A,m,k)\u000D\u000A        if m \u003C\u003D 0:\u000D\u000A            return B[k\u002D1]\u000D\u000A        if k\u003C\u003D1:\u000D\u000A            return min(A[0],B[0])\u000D\u000A        pa \u003D min(k/2,m)\u000D\u000A        pb \u003D k \u002D pa\u000D\u000A        if A[pa\u002D1] \u003C B[pb\u002D1]:\u000D\u000A            return self.findKth(A[pa:],m\u002Dpa,B,n,k\u002Dpa)\u000D\u000A        elif A[pa\u002D1] \u003E B[pb\u002D1]:\u000D\u000A            return self.findKth(A,m,B[pb:],n\u002Dpb,k\u002Dpb)\u000D\u000A        else:\u000D\u000A            return A[pa\u002D1]\u000D\u000A        ';
Median of Two Sorted Arrays =>     scope.code.cpp = 'double findKth(int a[], int m, int b[], int n, int k)\u000D\u000A{\u000D\u000A\u0009//always assume that m is equal or smaller than n\u000D\u000A\u0009if (m \u003E n)\u000D\u000A\u0009\u0009return findKth(b, n, a, m, k)\u003B\u000D\u000A\u0009if (m \u003D\u003D 0)\u000D\u000A\u0009\u0009return b[k \u002D 1]\u003B\u000D\u000A\u0009if (k \u003D\u003D 1)\u000D\u000A\u0009\u0009return min(a[0], b[0])\u003B\u000D\u000A\u0009//divide k into two parts\u000D\u000A\u0009int pa \u003D min(k / 2, m), pb \u003D k \u002D pa\u003B\u000D\u000A\u0009if (a[pa \u002D 1] \u003C b[pb \u002D 1])\u000D\u000A\u0009\u0009return findKth(a + pa, m \u002D pa, b, n, k \u002D pa)\u003B\u000D\u000A\u0009else if (a[pa \u002D 1] \u003E b[pb \u002D 1])\u000D\u000A\u0009\u0009return findKth(a, m, b + pb, n \u002D pb, k \u002D pb)\u003B\u000D\u000A\u0009else\u000D\u000A\u0009\u0009return a[pa \u002D 1]\u003B\u000D\u000A}\u000D\u000A\u000D\u000Aclass Solution\u000D\u000A{\u000D\u000Apublic:\u000D\u000A\u0009double findMedianSortedArrays(int A[], int m, int B[], int n)\u000D\u000A\u0009{\u000D\u000A\u0009\u0009int total \u003D m + n\u003B\u000D\u000A\u0009\u0009if (total \u0026 0x1)\u000D\u000A\u0009\u0009\u0009return findKth(A, m, B, n, total / 2 + 1)\u003B\u000D\u000A\u0009\u0009else\u000D\u000A\u0009\u0009\u0009return (findKth(A, m, B, n, total / 2)\u000D\u000A\u0009\u0009\u0009\u0009\u0009+ findKth(A, m, B, n, total / 2 + 1)) / 2\u003B\u000D\u000A\u0009}\u000D\u000A}\u003B';
Longest Substring Without Repeating Characters =>     scope.code.java = 'public class Solution {\u000D\u000A    public int lengthOfLongestSubstring(String s) {\u000D\u000A        if(s \u003D\u003D null)\u000D\u000A\u0009\u0009\u0009return 0\u003B\u000D\u000A\u0009\u0009if(s.equals(\u0022\u0022))\u000D\u000A\u0009\u0009    return 0\u003B\u000D\u000A\u0009\u0009if(s.length() \u003D\u003D 1)\u000D\u000A\u0009\u0009\u0009return 1\u003B\u000D\u000A\u0009\u0009int max_length \u003D 1\u003B\u000D\u000A\u0009\u0009int begin \u003D 0\u003B\u000D\u000A\u0009\u0009Map\u003CCharacter,Integer\u003E position \u003D new HashMap\u003CCharacter,Integer\u003E()\u003B\u000D\u000A\u0009\u0009for(int current\u003D0\u003Bcurrent\u003Cs.length()\u003Bcurrent++){\u000D\u000A\u0009\u0009\u0009char c \u003D s.charAt(current)\u003B\u000D\u000A\u0009\u0009\u0009if(!position.containsKey(c)){\u000D\u000A\u0009\u0009\u0009\u0009position.put(c, current)\u003B\u000D\u000A\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009if(position.get(c)\u003E\u003Dbegin){\u000D\u000A\u0009\u0009\u0009\u0009\u0009begin \u003D position.get(c) + 1\u003B\u000D\u000A\u0009\u0009\u0009\u0009\u0009position.put(c, current)\u003B\u000D\u000A\u0009\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009\u0009position.put(c, current)\u003B\u000D\u000A\u0009\u0009\u0009\u0009}\u0009\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009if(current\u002Dbegin+1 \u003E\u003D max_length)\u000D\u000A\u0009\u0009\u0009\u0009max_length \u003D current\u002Dbegin+1\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return max_length\u003B\u000D\u000A    }\u000D\u000A}';
Add Two Numbers =>     scope.code.java = '/**\u000D\u000A * Definition for singly\u002Dlinked list.\u000D\u000A * public class ListNode {\u000D\u000A *     int val\u003B\u000D\u000A *     ListNode next\u003B\u000D\u000A *     ListNode(int x) {\u000D\u000A *         val \u003D x\u003B\u000D\u000A *         next \u003D null\u003B\u000D\u000A *     }\u000D\u000A * }\u000D\u000A */\u000D\u000Apublic class Solution {\u000D\u000A    public ListNode addTwoNumbers(ListNode l1, ListNode l2){\u000D\u000A\u0009\u0009if(l1 \u003D\u003D null) return l2\u003B\u000D\u000A\u0009\u0009if(l2 \u003D\u003D null) return l1\u003B\u000D\u000A\u0009\u0009int data \u003D 0\u003B\u000D\u000A\u0009\u0009int res \u003D 0\u003B\u000D\u000A\u0009\u0009ListNode pre \u003D null,head\u003Dnull,p\u003Dnull\u003B\u000D\u000A\u0009\u0009while(l1!\u003Dnull \u0026\u0026 l2!\u003Dnull){\u000D\u000A\u0009\u0009\u0009res +\u003D l1.val + l2.val\u003B\u000D\u000A\u0009\u0009\u0009data \u003D res % 10\u003B\u000D\u000A\u0009\u0009\u0009res /\u003D10\u003B\u000D\u000A\u0009\u0009\u0009if(pre!\u003Dnull){\u000D\u000A\u0009\u0009\u0009\u0009p \u003D new ListNode(data)\u003B\u000D\u000A\u0009\u0009\u0009\u0009pre.next \u003D p\u003B\u000D\u000A\u0009\u0009\u0009\u0009pre \u003D p\u003B\u000D\u000A\u0009\u0009\u0009}else{\u000D\u000A\u0009\u0009\u0009\u0009pre\u003Dp\u003Dhead\u003Dnew ListNode(data)\u003B\u000D\u000A\u0009\u0009\u0009}\u000D\u000A\u0009\u0009\u0009l1 \u003D l1.next\u003B\u000D\u000A\u0009\u0009\u0009l2 \u003D l2.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(l1 !\u003D null){\u000D\u000A\u0009\u0009\u0009res +\u003D l1.val\u003B\u000D\u000A\u0009\u0009\u0009data \u003D res % 10\u003B\u000D\u000A\u0009\u0009\u0009res /\u003D10\u003B\u000D\u000A\u0009\u0009\u0009p \u003D new ListNode(data)\u003B\u000D\u000A\u0009\u0009\u0009pre.next \u003D p\u003B\u000D\u000A\u0009\u0009\u0009pre \u003D p\u003B\u000D\u000A\u0009\u0009\u0009l1 \u003D l1.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009while(l2 !\u003D null){\u000D\u000A\u0009\u0009\u0009res +\u003D l2.val\u003B\u000D\u000A\u0009\u0009\u0009data \u003D res % 10\u003B\u000D\u000A\u0009\u0009\u0009res /\u003D10\u003B\u000D\u000A\u0009\u0009\u0009p \u003D new ListNode(data)\u003B\u000D\u000A\u0009\u0009\u0009pre.next \u003D p\u003B\u000D\u000A\u0009\u0009\u0009pre \u003D p\u003B\u000D\u000A\u0009\u0009\u0009l2 \u003Dl2.next\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009if(res \u003E 0){\u000D\u000A\u0009\u0009\u0009p \u003D new ListNode(1)\u003B\u000D\u000A\u0009\u0009\u0009pre.next \u003D p\u003B\u000D\u000A\u0009\u0009\u0009p.next \u003D null\u003B\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return head\u003B\u000D\u000A\u0009}\u000D\u000A}';
Two Sum =>     scope.code.java = 'public class Solution {\u000D\u000A    public int[] twoSum(int[] numbers, int target) {\u000D\u000A        Map\u003CInteger,Integer\u003E tmp \u003D new HashMap\u003CInteger,Integer\u003E()\u003B\u000D\u000A\u0009\u0009int[] result \u003D new int[2]\u003B\u000D\u000A\u0009\u0009int remain \u003D 0\u003B\u000D\u000A\u0009\u0009for(int i\u003D0\u003B i\u003Cnumbers.length\u003B i++){\u000D\u000A\u0009\u0009\u0009remain \u003D target \u002D numbers[i]\u003B\u000D\u000A\u0009\u0009\u0009if(tmp.containsKey(remain)){\u000D\u000A\u0009\u0009\u0009\u0009result[0] \u003D tmp.get(remain)+1\u003B\u000D\u000A\u0009\u0009\u0009\u0009result[1] \u003D i+1\u003B\u000D\u000A\u0009\u0009\u0009\u0009break\u003B\u000D\u000A \u0009\u0009\u0009}else{\u000D\u000A \u0009\u0009\u0009\u0009tmp.put(numbers[i], i)\u003B\u000D\u000A \u0009\u0009\u0009}\u000D\u000A\u0009\u0009}\u000D\u000A\u0009\u0009return result\u003B\u000D\u000A    }\u000D\u000A}';
